[
["index.html", "Interpretable Machine Learning Preface", " Interpretable Machine Learning A Guide for Making Black Box Models Explainable. Christoph Molnar 2018-06-10 Preface Machine learning has a huge potential to improve products, processes and research. But machines usually don’t give an explanation for their predictions, which creates a barrier for the adoption of machine learning. This book is about making machine learning models and their decisions interpretable. After exploring the concepts of interpretability, you will learn about simple, interpretable models and how to interpret them. The later chapters focus on general model-agnostic tools for analysing complex models and making their decisions interpretable. In an ideal future, machines will be able to explain their decisions and the algorithmic age we are moving towards will be as human as possible. This book is recommended for machine learning practitioners, data scientists, statisticians and anyone else interested in making machine decisions more human. You can buy the PDF and e-book version (epub, mobi) on leanpub.com. About me: My name is Christoph Molnar, I am a statistician and machine learner, working on making machine learning interpretable. If you are interested in bringing interpretability to your machine learning models, feel free to contact me! Mail: christoph.molnar.ai@gmail.com Website: https://christophm.github.io/ Follow me on Twitter! @ChristophMolnar Cover by @ArbeitAmText This book is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. "],
["intro.html", "Chapter 1 Introduction", " Chapter 1 Introduction This book will teach you how to make (supervised) machine learning models interpretable. The chapters contain some mathematical formulas, but you should be able to understand the ideas behind the methods even without the mathematics. This book is not for people who try to learn machine learning from scratch. If you are new to machine learning, there are loads of books and other resources for learning the basics. I recommend the book Elements of Statistical Learning from Hastie, Tibshirani, and Friedman (2009) 1 and Andrew Ng’s “Machine Learning” online course on coursera to get started with machine learning. Both the book and the course are available free of charge! New methods for machine learning interpretability are published at breakneck speed. Keeping update with all of them would be madness and simply impossible. That’s why you won’t find the most novel and shiny methods in this book, but rather the basic concepts of machine learning interpretability. These basics will prepare you well to make machine learning models interpretable. Internalizing the basic concepts also empowers you to better understand and evaluate any new paper on interpretability that has been published on arxiv.org in the last 5 minutes since you began to read this book (I may be exaggerating). This book starts with some (dystopian) short stories, which are not needed to understand the book, but hopefully are entertaining! Then the book explores the concepts of machine learning interpretability: It shows when interpretability is important and discusses different types of explanations. Definitions used throughout the book can be looked up here. Most of the models and methods explained are presented using real data examples described here. One way to make machine learning interpretable is to use interpretable models, like linear models or decision trees. The other option is the use model-agnostic interpretation tools, that can be applied to any supervised machine learning model. The model-agnostic chapter covers methods like partial dependence plots and permutation feature importance. Model-agnostic methods work by changing the input of the machine learning model and measuring changes in the output. Finish the book with an optimistic outlook on what the future of interpretable machine learning might look like. You can either read the book from beginning to end or jump directly to the methods that interest you. I hope you will enjoy the read! Hastie, T, R Tibshirani, and J Friedman. 2009. The elements of statistical learning. http://link.springer.com/content/pdf/10.1007/978-0-387-84858-7.pdf.↩ "],
["storytime.html", "1.1 Storytime", " 1.1 Storytime Get started with a few short stories. Each story is an - admittedly exaggerated - call for interpretable machine learning. If you are in a hurry, you can skip the stories. If you want to be entertained and (de-)motivated, read on! The format is inspired by Jack Clark’s Tech Tales in his Import AI Newsletter. If you like these kind of stories or are interested in AI, I recommend signing up. Lightning Never Strikes Twice 2030: A medical lab in Switzerland “It’s definitely not the worst way to die!” Tom summarised, trying to find something positive in the tragedy. He was removing the pump’s computer from the intravenous pole. “He just died for the wrong reasons.” Lena added. “And certainly with the wrong morphine pump! Just creating more work for us!” Tom complained, while he was unscrewing the pump’s back plate. After he had removed all the screws, he lifted the plate and put it aside. He plugged a cable into the diagnostic port. “You didn’t just complain about having a job, did you?” Lena gave him a mocking smile. “Of course not. Never!” he exclaimed with an ironic undertone. He booted the pump. Lena plugged the other end of the cable into her tablet. “Alright, diagnostics are running.” she announced. “I am really curious to see what went wrong.” “It certainly shot our John Doe to Nirvana. This high concentration of this morphine stuff. Man. I mean … that’s a first, right? Normally a broken pump gives too little of the sweet stuff or nothing. But never, you know, like this crazy shot.” Tom explained. “I know. You don’t have to convince me … Hey, look at that.” Lena held up the tablet. “Do you see this peek here? That’s the painkiller potency. Look: this line shows the reference level. The poor guy had a painkiller mix in his blood system that could kill him 17 times over. All injected by our pump here. And here …” she swiped, “Here you can see the moment of the patient’s demise.” “So, any idea what happened boss?” Tom asked his supervisor. “Hm … The sensory functions seem to be okay. Heart rate, oxygen levels, glucose, … The data were collected as expected. Some missing values in the blood oxygen data, but that’s not unusual. Look. It also picked up the slowing heart rate of the patient and the extremely low cortisol levels caused by the morphine derivate and the other pain blocking agents.” She continued swiping through the diagnostics. Tom stared in a gaze at the screen. It was his first real device failure to investigate. “Ok, here is our first piece of the puzzle. The system failed to send a warning to the hospital communication channel. The warning was triggered, but rejected on the protocol level. Might be our fault, but could be also the hospitals fault. Please send the logs over to the IT team.” Lena told Tom. Tom nodded, eyes still locked on the screen. Lena continued. “It’s weird. The warning should also have triggered the shutdown of the pump. But it obviously failed to do so. That must be a bug. Something the quality team missed. Something really bad. Maybe connected to the protocol issue.” “So, the pump’s emergency systems somehow broke, but why did the pump go full bananas and inject so much painkiller?” Tom wondered. “Good question. You are right. Protocol emergency failure aside, the pump shouldn’t have administered this amount of medication in the first place. The algorithm should have stopped much earlier on its own, given the low cortisol level and other warning signs.” Lena explained. “Maybe some bad luck, like a one in a million thing, like being hit by a lightning?” Tom asked her. “No Tom. If you would have read the documentation, which I sent to you, you would know that the pump was first trained on animal trials, later on humans to learn on its own how to find the perfect amount of pain killer, given the sensory input. The pump’s algorithm might be opaque and complex, but it is not random. That means the pump would show the same behaviour in the exact same situation. Our patient would die again. Some combination or unwanted interaction of the sensory inputs must have triggered the erratical behaviour of the pump. That’s why we have to dig deeper and find out what happened here.” Lena explained. “I see …” Tom responded, lost in thoughts. “Wasn’t the patient going to die soon anyway? Because of cancer or something?” Lena nodded while reading the analysis report. Tom got up, and walked to the window. He looked outside, eyes fixating on some point in the distance. “Maybe the machine did him a favour, you know, like freeing him from the pain. No more suffering. Maybe it just did the right thing. Like a lightning, but, you know, a good one. I mean like the lottery, but not random. For a reason. If I were the pump, I would have done the same.” She finally lifted her head and looked at him. He continued looking at something outside. Nobody said anything for a minute or two. Lena lowered her head again and continued the analysis. “No Tom. It’s a bug… Just some goddam bug”. Trust Fall 2050, A subway station in Singapore She was rushing to Bishan subway station. With her thoughts she was already at work. The tests for the new neural architecture should have finished by now. She lead the re-design of the government’s “tax affinity prediction system for individual entities”, which predicts if an individual will hide money from the tax office. Her team came up with an elegant piece of engineering. If successful, the system would not only serve the tax office, but also feed into other systems, like the anti-terrorist defence and the trade registry. One day, the government might even integrate it into the civic trust score. The trust system estimates how trustworthy an individual is. The estimate affects every part of your daily life, like getting a loan or how long you have to wait when getting a new passport. Descending the escalator, she imagined how an integration into the current trust score system could look like. Routinely, she wiped her hand over the RFID reader without reducing her walking speed. Her mind was occupied, yet a dissonance of sensory expectations and reality rang alarm bells in her brain. Too late. Nose first she ran into the subway entrance gate and fell, bottom first, onto the floor. The door was supposed to open, … but it didn’t. Baffled, she stood up and looked at the gate’s screen. “Please try again some other time.” it suggested in friendly colours. A person walked by, and, ignoring her, wiped his hand over the reader. The doors opened and he walked through. The doors closed again. She wiped her nose. It hurt, but at least it wasn’t bleeding. She tried to open the door, but got rejected again. It was odd. Maybe her public transport account did not have sufficient tokens. She raised her watch to check the account balance. “Login denied. Please contact your Citizens Advice Bureau!” the watch informed her. A feeling of nausea hit her like a fist to the stomach. With trembling hands she started the mobile game “Sniper Guild”, an ego-shooter. After a few seconds, the loading screen shut down. She felt dizzy and sat down on the floor again. There was only one possible explanation: Her trust score had dropped. Substantially. A small drop meant minor inconveniences, like not getting first class flights. A low trust score was rare and meant that you were classified as a threat to society. One measure for dealing with those people was to keep them from public places - for example the subway. The government restricted financial transactions of low-trust subjects. They also started actively monitoring of your behaviour on social media, even going as far as to restrict certain contents, like violent games. It became exponentially more difficult to increase your trust score, the lower it was. People with a very low trust score usually never recovered. She could think of no reason why her score should have dropped. The score was based on machine learning. It worked like a well oiled engine, stabilising society. The performance of the trust score system was always closely monitored. Machine learning had become a lot better since the beginning of the century. It had become so efficient that decisions made by the trust score system could not be disputed. An infallible system. She laughed hysterically. Infallible system. If only. The system failed rarely. But it did fail. She was an edge case; an error of the system; from now on, an outcast. Nobody dared to question the system. It had become too integrated into the government, into society itself to be questioned. In democratic countries it was forbidden to form anti-democratic movements, not because they where inherently vicious, but because they would de-stabilise the current system. The same logic applied to algorithmic critique: Critique in the algorithms was forbidden, because of its danger to the status quo. The algorithmic trust was the very fabric the societal order was made of. For the greater good, rare incorrect trust scorings were accepted silently. Hundreds of other prediction systems and databases were feeding into the score, so it was impossible to know what triggered the drop in her score. Wild emotions twisted her, most of all, terror. She vomited on the floor. Her tax affinity system was eventually integrated into the trust system, but she never got to know. Fermi’s Paperclips Year 612 AMS (after mars settlement): A museum on Mars “History is boring” Xola whispered to her friend. Xola, a blue-haired girl, was lazily chasing with her left hand one of the projector drones, that were buzzing in the room. “History is important!” the teacher said with an upset voice, looking at the girls. Xola blushed. She hadn’t expected her teacher to overhear her. “Xola, what did you just learn?” the teacher asked her. “That the ancient people used all resources from earther planet and then they died?” she asked carefully. “No. They made the climate go hot and it wasn’t the people, it was the computers and machines. And it’s planet earth, not earther planet.” another girl named Lin added. Xola nodded in agreement. With a hint of a pride smile, the teacher nodded. “You are both right. Do you know why it happened?” “Because the humans were short-sighted and greedy?” Xola wondered. “The humans couldn’t stop their machines!” Lin blurted out. “Again, you are both right!” the teacher resolved, “But it’s a lot more complicated than that. Most people at the time were not aware what was happening. Some were seeing the drastic changes but could not revert them. The most famous piece from that time is a poem, by an anonymous author. It captures best what happened at that time. Listen carefully!” The teacher started the poem. A dozen of the little drones repositioned themselves in front of the kids’ eyes and started projecting the video. It showed a person in a suit, standing in a forest but with only tree stumps left. He started reciting: The machines compute; the machines predict. We march on, as we are part of it. We chase an optimum as trained. The optimum is one-dimensional, local and unconstrained. Silicon and flesh, chasing exponentiality. Growth is our mentality. When all rewards are collected, and side-effects neglected; When all coins are mined, and nature has fallen behind; There will be trouble, after all, exponential growth is a bubble. The tragedy of the commons unfolding, exploding, before our eyes. Cold computing and icy greed, fill the earth with heat. Everything is dying, And we are complying. Like horses with blinders we race the race of our own creation, towards the Great Filter of civilisation. And so we march on, relentlessly. As we are part of the machine. Embracing entropy. “A grim reminder.” the teacher broke the silence in the room, “It’s uploaded to your library. Your homework is to memorise it until next week.” Xola sighed. She managed to catch one of the little drones. The drone was warm from the CPU and the motors. Xola liked how it warmed her hands. "],
["what-is-machine-learning.html", "1.2 What Is Machine Learning?", " 1.2 What Is Machine Learning? Machine learning is a method for teaching computers to make and improve predictions or behaviours based on data. Predicting the value of a house by learning from historical house sales can be done with machine learning. The book focuses on supervised machine learning, which includes all problems where we know the label or the outcome of interest (e.g. the past sale prices of houses) and want to learn to predict. Excluded from supervised learning are, for example, clustering tasks (=unsupervised learning), where we have no label, but want to find clusters of data points. Also excluded are things like reinforcement learning, where an agent learns to optimise some reward by acting in an environment (e.g. a computer playing Tetris). The goal in supervised learning is to learn a predictive model that maps features (e.g. house size, location, type of floor, …) to an output (e.g. value of the house). If the output is categorical, the task is called classification and if it is numerical, then regression. Machine learning is a set of algorithms that can learn these mappings from training data, which are pairs of input features and a target. The machine learning algorithm learns a model by changing parameters (like linear weights) or learning structures (like trees). The algorithm is guided by a score or loss function that is minimised. In the house value example, the machine minimises some form of difference between the estimated house sales price and the predicted sales price. A fully trained machine learning model can then be used to make predictions for new instances and be integrated into a product or process. Estimating house values, recommending products, identifying street signs, counting people on the street, assessing a person’s credit worthiness and detecting fraud: All these examples have in common that they can and increasingly are realised with machine learning. The tasks are different, but the approach is the same: Step 1 is to collect data. The more, the better. The data needs to have the information you want to predict and additional information from which the prediction should be made. For a street sign detector (“Is there a street sign in the image?”) you would collect street images and label them accordingly with street sign yes vs. no. For a loan default predictor you need historical data from actual loans, the information if the customers defaulted on their loans and data that helps you predict, like the customers income, age and so on. For a house value estimator, you would want to collect data from historical house sales and information about the real estate like size, location and so on. Step 2: Feed this information into a machine learning algorithm, which produces a sign detector model, a credit worthiness model or a house value estimator. This model can then be used in Step 3: Integrate the model into the product or process, like a self-driving car, a loan application process or a real estate marketplace website. Machines exceed humans in a lot of tasks, like playing chess (or, since recently, Go) or predicting the weather. Even if the machine is as good as a human at a task, or slightly worse, there remain big advantages in speed, reproducibility and scale. A machine learning model that has been implemented once, can do a task much faster than humans, will reliably produce the same results from the same input and can be copied endlessly. Replicating a machine learning model on another machine is fast and cheap. Training a second human to do a task can take decades (especially when they are young) and is very costly. A big disadvantage of using machine learning is that insights about the data and the task the machine is solving are hidden within increasingly complex models. You need millions of numbers to describe a deep neural network and there is no way to understand the model in its entirety. Other models, like the RandomForest, consist of hundreds of decision trees that “vote” to make predictions. Again, to fully understand how the decision was made, you would need to look into the votes and structures of each of the hundreds of trees. That just does not work out, no matter how clever you are or how good your working memory is. The best performing models are blends of multiple models (also called ensembles), which in itself cannot be interpreted, even if each single model would be interpretable. If you only focus on performance, you automatically will get more and more opaque models. Just have a look at interviews with winners on the kaggle.com machine learning competition platform: The winning models were mostly ensembles of models or very complex models like boosted trees or deep neural networks. "],
["definitions.html", "1.3 Definitions", " 1.3 Definitions To avoid confusion through ambiguity, here are some definitions of terms used in this book: An Algorithm is a set of rules that a machine follows to achieve a particular goal 2. A Machine learning algorithm is a set of rules that a machine follows to learn how to a achieve a particular goal. The output of a machine learning algorithm is a machine learning model. A (Machine learning) Model is the outcome of a machine learning algorithm. This can be a set of weights for a linear model or for a neural network plus the information about the architecture. Dataset: A table containing the data from which the machine learns. Features: The features/information used for prediction/classification/clustering. A feature is one column in the dataset. Target: The thing the machine learns to predict. (machine learning) Task: The combination of a dataset with features and a target. Depending on the type of the target, the task can be classification, regression, survival analysis, clustering, or outlier detection. Prediction: The machine learning model “guesses” what the target value should be based on given features. Instance: One row in the dataset. “Definition of Algorithm.” 2017. https://www.merriam-webster.com/dictionary/algorithm.↩ "],
["interpretability.html", "Chapter 2 Interpretability", " Chapter 2 Interpretability Throughout the book, I will use this rather simple, yet elegant definition of interpretability from Miller (2017) 3 : Interpretability is the degree to which a human can understand the cause of a decision. Another take is: Interpretability is the degree to which a human can consistently predict the model’s result. The higher the interpretability of a model, the easier it is for someone to comprehend why certain decisions (read: predictions) were made. A model has better interpretability than another model, if its decisions are easier to comprehend for a human than decisions from the second model. I will be using both the terms interpretable and explainable equally. Like Miller (2017), I believe it makes sense to distinguish between the terms interpretability/explainability and explanation. Making a machine learning interpretable can, but does not necessarily have to, imply providing a (human-style) explanation of a prediction. See the section about explanations to learn what we humans see as a good explanation. Miller, Tim. 2017. “Explanation in Artificial Intelligence: Insights from the Social Sciences.” arXiv Preprint arXiv:1706.07269.↩ "],
["interpretability-importance.html", "2.1 The Importance of Interpretability", " 2.1 The Importance of Interpretability If a machine learning model performs well, why not just trust the model and ignore why it made a certain decision? “The problem is that a single metric, such as classification accuracy, is an incomplete description of most real-world tasks.” (Doshi-Velez and Kim 2017 4) Let’s dive deeper into the reasons why interpretability is so important. In predictive modelling, you have to make a trade-off: Do you simply want to know what is predicted? For example the probability that a client will churn or how effective some medication will be for a patient. Or do you want to know why the prediction was made and possibly paying for the interpretability with a drop in accuracy? In some cases you don’t care why a decision was made, only the assurance that the predictive performance was good on a test dataset is enough. But in other cases, knowing the ‘why’ can help you understand more about the problem, the data and why a model might fail. Some models might not need explanations, because they are used in a low risk environment, meaning a mistake has no severe consequences, (e.g. a movie recommender system) or the method has already been extensively studied and evaluated (e.g. optical character recognition). The necessity for interpretability comes from an incompleteness in the problem formalisation (Doshi-Velez and Kim 2017), meaning that for certain problems or tasks it is not enough to get the answer (the what). The model also has to give an explanation how it came to the answer (the why), because a correct prediction only partially solves your original problem. The following reasons drive the demand for interpretability and explanations (Doshi-Velez and Kim 2017 and Miller 2017) Human curiosity and learning: Humans have a mental model of their environment, which gets updated when something unexpected happens. This update is done by finding an explanation for the unexpected event. For example, a human feels unexpectedly sick and asks himself: “Why do I feel so sick?”. He learns that he becomes sick every time he eats those red berries. He updates his mental model and decides that the berries caused the sickness and therefore should be avoided. Curiosity and learning is important for any machine learning model used in the research context, where scientific findings stay completely hidden, when the machine learning model only gives predictions without explanations. To facilitate learning and satisfy curiosity about why certain predictions or behaviours are created by machines, interpretability and explanations are crucial. Of course, humans don’t need an explanation for everything that happens. Most people are okay with not understanding how a computer works. The emphasis of this point is more on unexpected events, that makes us curious. Like: Why is my computer shutting down unexpectedly? Closely related to learning is the human desire to find meaning in the world. We want to reconcile contradictions or inconsistencies between elements of our knowledge structures. “Why did my dog bite me, even though it has never done so before?” a human might ask himself. There is a contraction between the knowledge about the dog’s past behaviour and the newly made, unpleasant experience of the bite. The explanation of the vet reconciles the dog holders contradiction: “The dog was under stress and did bite, dogs are animals and this can happen.” The more a machine’s decision affects a human’s life, the more important it will be for the machine to explain its behaviour. When a machine learning model rejects a loan application, this could be quite unexpected for the applicant. He can only reconcile this inconsistency between expectation and reality by having some form of explanation. The explanations don’t actually have to fully explain the situation, but should address a main cause. Another example is algorithmic product recommendation. Personally, I always reflect on why certain products or movies have been recommended to me algorithmically. Often it is quite clear: The advertising is following me on the Internet because I have bought a washing machine recently, and I know that I will be followed by washing machine advertisements the next days. Yes, it makes sense to suggest gloves, when I already have a winter hat in my shopping basket. The algorithm recommended this movie, because users that liked other movies that I also liked, enjoyed the recommended movie. Increasingly, Internet companies are adding explanations to their recommendations. A good example is the Amazon product recommendation based on frequently bought product combinations: FIGURE 2.1: Recommended products when buying some paint from Amazon. Visited on December 5th 2012. There is a shift in many scientific disciplines from qualitative to quantitative methods (e.g. sociology, psychology), and also towards machine learning (biology, genomics). The goal of science is to gain knowledge, but many problems can only be solved with big datasets and black box machine learning models. The model itself becomes a source of knowledge, instead of the data. Interpretability allows to tap into this additional knowledge captured by the model. Machine learning models are taking over real world tasks, that demand safety measurements and testing. Imagine a self-driving car automatically detects cyclists, which is as desired. You want to be 100% sure that the abstraction the system learned will be fail-safe, because running over cyclists is quite bad. An explanation might reveal that the most important feature learned is to recognise the two wheels of a bike and this explanation helps you to think about edge cases like bikes with side bags, that partially cover the wheels. By default most machine learning models pick up biases from the training data. This can turn your machine learning models into racists which discriminate against protected groups. Interpretability is a useful debugging tool to detect bias in machine learning models. It might happen that the machine learning model you trained for automatically approving or rejecting loan applications discriminates against some minority. Your main goal is to give out loans to people that will pay them back eventually. In this case, the incompleteness in the problem formulation lies in the fact that you not only want to minimise loan defaults, but you are also required to not discriminate based on certain demographics. This is an additional constraint, which is part of your problem formulation (Handing out loans in a low-risk and compliant way), which is not captured by the loss function, which the machine learning model optimises. The process of integrating machines and algorithms into our daily lives demands interpretability to increase social acceptance. People attribute beliefs, desires, intentions and so on to objects. In a famous experiment, Heider and Simmel (1944) 5 showed the participants videos of shapes, where a circle opened a door to enter a “room” (which was simply a rectangle). The participants described the actions of the shapes as they would describe the actions of a human agent, attributing intentions and even emotions and personality traits to the shapes. Robots are a good example, like my vacuum cleaner, which I named ‘Doge’. When Doge gets stuck, I think: “Doge wants to continue cleaning, but asks me for help because it got stuck.” Later, when Doge finished cleaning and searches the home base to recharge I think: “Doge has the desire to recharge and intents to find the home base”. Also I attribute personality traits: “Doge is a bit dumb, but in a cute way”. These are my thoughts, especially when I find out that Doge threw over some plant while cleaning the house dutifully. A machine or algorithm explaining its prediction will receive more acceptance. See also the chapter about explanations, which argues that explanations are a social process. Explanations are used to manage social interactions. Through the creation of a shared meaning of something, the explainer influences the actions, emotions and beliefs of the receiver of the explanation. In order to allow a machine to interact with us, it might need to shape our emotions and beliefs. Machines have to “persuade” us, so that we believe that they can achieve their intended goal. I would not completely accept my robot vacuum cleaner if it would not explain its behaviour to some degree. The vacuum cleaner creates a shared meaning of, for example, an “accident” (like getting stuck on the bathroom carpet … again) by explaining that it got stuck, instead of simply stopping to work without comment. Interestingly, there can be a misalignment between the goal of the explaining machine, which is generating trust, and the goal of the recipient, which is to understand the prediction or behaviour. Maybe the correct explanation why Doge got stuck could be that the battery was very low, additionally one of the wheels is not working properly and on top of that there is a bug that causes the robot to re-try to go to the same spot over and over again, even though there was some obstacle in the way. These reasons (and some more) caused the robot to get stuck, but it only explained that there was something in the way, and this was enough for me to trust its behaviour, and to get a shared meaning of that accident, which I can share with my girlfriend. (“By the way, Doge got stuck again in the bathroom, we have to remove the carpets before we let it clean”). The example of the robot getting stuck on the carpet might not even require an explanation, because I can explain it to myself by observing that Doge can’t move on this carpet mess. But there are other situations, which are less obvious, like a full dirt bag. FIGURE 2.2: Doge, my vacuum cleaner got stuck. As an explanation for the accident, Doge told me that it needs to be on a flat surface. Only with interpretability can machine learning algorithms be debugged and audited. So even in low risk environments, like movie recommendation, interpretability in the research and development stage as well as after deployment is valuable. Because later, when some model is used in a product, things can go wrong. Having an interpretation for a faulty prediction helps to understand the cause of the fault. It delivers a direction for how to fix the system. Consider an example of a husky versus wolf classifier, that misclassifies some huskies as wolfs. Using interpretable machine learning methods, you would find out that the misclassification happened due to the snow on the image. The classifier learned to use snow as a feature for classifying images as wolfs, which might make sense in terms of separating features in the training dataset, but not in the real world use. If you can ensure that the machine learning model can explain decisions, the following traits can also be checked more easily (Doshi-Velez and Kim 2017): Fairness: Making sure the predictions are unbiased and not discriminating against protected groups (implicit or explicit). An interpretable model can tell you why it decided that a certain person is not worthy of a credit and for a human it becomes easier to judge if the decision was based on a learned demographic (e.g. racial) bias. Privacy: Ensuring that sensitive information in the data is protected. Reliability or Robustness: Test that small changes in the input don’t lead to big changes in the prediction. Causality: Check if only causal relationships are picked up. Meaning a predicted change in a decision due to arbitrary changes in the input values are also happening in reality. Trust: It is easier for humans to trust a system that explains its decisions compared to a black box. Doshi-Velez, Finale, and Been Kim. 2017. “Towards A Rigorous Science of Interpretable Machine Learning,” no. Ml: 1–13. http://arxiv.org/abs/1702.08608.↩ Heider, Fritz, and Marianne Simmel. 1944. “An Experimental Study of Apparent Behavior.” The American Journal of Psychology 57 (2). JSTOR: 243–59.↩ "],
["criteria-for-interpretability-methods.html", "2.2 Criteria for Interpretability Methods", " 2.2 Criteria for Interpretability Methods Methods for machine learning interpretability can be classified according to different criteria: Intrinsic or post hoc? Intrinsic interpretability means selecting and training a machine learning model that is considered to be intrinsically interpretable (for example short decision trees). Post hoc interpretability means selecting and training a black box model (for example a neural network) and applying interpretability methods after the training (for example measuring the feature importance). The “intrinsic or post hoc”-criterion determined the layout of the chapters in the book: The two main chapters are the intrinsically interpretable models chapter and the post hoc (and model-agnostic) interpretability methods chapter. Outcome of the interpretability method: The different interpretability methods can be roughly differentiated according to their outcomes: Feature summary statistic: Many interpretability methods provide a kind of summary statistic of how each feature affects the model predictions. These can be feature importance measures or statistics about the interaction strength between features. Feature summary visualization: Most feature summary statistics can be visualized. However, some feature summaries can only be visualized and not meaningfully be placed in a table. The partial dependence of a feature is such a case. For non-linear relationships, partial dependence plots are arbitrary curves showing a feature and the average predicted outcome. Model internals (e.g. learned weights): The interpretation of intrinsically interpretable models falls under this category. Examples are the weights in linear models or the learned tree structure (which features and feature values are used for the splits?) of decision trees. The lines are blurred between model internals and feature summary statistic in, for example, linear models, because the weights are both model internals and at the same time summary statistics for the features. Another method that outputs model internals is the visualization of feature detectors that are learned in convolutional neural networks. Interpretability methods that output model internals are model-specific by definition (see next point). Data point: This category includes all methods that return data points (can be existing or newly created) to make a model interpretable. Counterfactuals, for example: To explain the prediction of a data point, find a similar data point by changing some of the features for which the predicted outcome changes in a relevant way (like a flip in the predicted class). Another example is the identification of prototypes of predicted classes. Interpretability methods that output new data points require that the data points themselves can be interpreted. This works well for images and text, but is less useful for tabular data with hundreds of features. Intrinsically interpretable model: This is a little circular, but one solution to interpreting black box models is to approximate them (either globally or locally) with an interpretable model. The interpretable model themselves are interpreted by internal model parameter or feature summary statistics. Model-specific or model-agnostic?: Model-specific interpretation tools are limited to specific model classes. The interpretation of regression weights in a linear model is a model-specific interpretation, since - by definition - the interpretation of intrinsically interpretable models is always model-specific. Any tool that only works for e.g. interpreting neural networks is model-specific. Model-agnostic tools can be used on any machine learning model and are usually post hoc. These agnostic methods usually operate by analysing feature input and output pairs. By definition, these methods can’t have access to any model internals like weights or structural information. Local or global?: Does the interpretation method explain a single prediction or the entire model behavior? Or is the scope somewhere in between? Read more about the scope criterion in the next section. "],
["scope-of-interpretability.html", "2.3 Scope of Interpretability", " 2.3 Scope of Interpretability An algorithm trains a model, which produces the predictions. Each step can be evaluated in terms of transparency or interpretability. 2.3.1 Algorithm transparency How does the algorithm create the model? Algorithm transparency is about how the algorithm learns a model from the data and what kind of relationships it is capable of picking up. If you are using convolutional neural networks for classifying images, you can explain that the algorithm learns edge detectors and filters on the lowest layers. This is an understanding of how the algorithm works, but not of the specific model that is learned in the end and not about how single predictions are made. For this level of transparency, only knowledge about the algorithm and not about the data or concrete learned models are required. This book focuses on model interpretability and not algorithm transparency. Algorithms like the least squares method for linear models are well studied and understood. They score high in transparency. It is not clear how they exactly work, so they are less transparent. 2.3.2 Global, Holistic Model Interpretability How does the trained model make predictions? You could call a model interpretable if you can comprehend the whole model at once (Lipton 20166). To explain the global model output, you need the trained model, knowledge about the algorithm and the data. This level of interpretability is about understanding how the model makes the decisions, based on a holistic view of its features and each of the learned components like weights, parameters, and structures. Which features are the important ones and what kind of interactions are happening? Global model interpretability helps to understand the distribution of your target variable based on the features. Arguably, global model interpretability is very hard to achieve in practice. Any model that exceeds a handful of parameters or weights, probably won’t fit in an average human’s short term memory. I’d argue that you cannot really imagine a linear model with 5 features and draw in your head the hyperplane that was estimated in the 5-dimensional feature space. Each feature space with more than 3 dimensions is just not imaginable for humans. Usually when people try to comprehend a model, they look at parts of it, like the weights in linear models. 2.3.3 Global Model Interpretability on a Modular Level How do parts of the model influence predictions? You might not be able to comprehend a Naive Bayes model with many hundred features, because there is no way you could hold all the feature weights in your brain’s working memory. But you can understand a single weight easily. Not many models are interpretable on a strict parameter level. While global model interpretability is usually out of reach, there is a better chance to understand at least some models on a modular level. In the case of linear models, the interpretable parts are the weights and the distribution of the features, for trees it would be splits (used feature plus the cut-off point) and leaf node predictions. Linear models for example look like they would be perfectly interpretable on a modular level, but the interpretation of a single weight is interlocked with all of the other weights. The interpretation of a single weight always comes with the footnote that the other input features stay at the same value, which is not the case in many real world applications. A linear model predicting the value of a house, which takes into account both the size of the house and the number of rooms might have a negative weight for the rooms feature, which is counter intuitive. But it can happen, because there is already the highly correlated flat size feature and in a market where people prefer bigger rooms, a flat with less rooms might be worth more than a flat with more rooms when both have the same size. The weights only make sense in the context of the other features used in the model. But arguably the weights in a linear model still have better interpretability than the weights of a deep neural network. 2.3.4 Local Interpretability for a Single Prediction Why did the model make a specific decision for an instance? You can zoom in on a single instance and examine what kind of prediction the model makes for this input, and why it made this decision. When you look at one example, the local distribution of the target variable might behave more nicely. Locally it might depend only linearly or monotonic on some features rather than having a complex dependence on the features. For example the value of an apartment might not depend linearly on the size. But if you only look at a specific apartment of 100 square meters and check how the price changes by going up and down by 10 square meters, there is a chance that this subregion in your data space is linear. Local explanations can be more accurate compared to global explanations because of this. This book presents methods that can make single predictions more interpretable in the section about model-agnostic methods. 2.3.5 Local Interpretability for a Group of Prediction Why did the model make specific decisions for a group of instances? The model predictions for multiple instances can be explained by either using methods for global model interpretability (on a modular level) or single instance explanations. The global methods can be applied by taking the group of instances, pretending it’s the complete dataset, and using the global methods on this subset. The single explanation methods can be used on each instance and listed or aggregated afterwards for the whole group. Lipton, Zachary C. 2016. “The Mythos of Model Interpretability.” ICML Workshop on Human Interpretability in Machine Learning, no. Whi.↩ "],
["evaluating-interpretability.html", "2.4 Evaluating Interpretability", " 2.4 Evaluating Interpretability There is no real consensus on what interpretability in machine learning is. Also it is not clear how to measure it. But there is some first research on it and the attempt to formulate some approaches for the evaluation, as described in the following section. 2.4.1 Approaches for Evaluating the Interpretability Quality Doshi-Velez and Kim (2017) propose three major levels when evaluating interpretability: Application level evaluation (real task): Put the explanation into the product and let the end user test it. For example, on an application level, radiologists would test fracture detection software (which includes a machine learning component to suggest where fractures might be in an x-ray image) directly in order to evaluate the model. This requires a good experimental setup and an idea of how to assess the quality. A good baseline for this is always how good a human would be at explaining the same decision. Human level evaluation (simple task) is a simplified application level evaluation. The difference is that these experiments are not conducted with the domain experts, but with lay humans. This makes experiments less expensive (especially when the domain experts are radiologists) and it is easier to find more humans. An example would be to show a user different explanations and the human would choose the best. Function level evaluation (proxy task) does not require any humans. This works best when the class of models used was already evaluated by someone else in a human level evaluation. For example it might be known that the end users understand decision trees. In this case, a proxy for explanation quality might be the depth of the tree. Shorter trees would get a better explainability rating. It would make sense to add the constraint that the predictive performance of the tree remains good and does not drop too much compared to a larger tree. 2.4.1.1 More on Function Level Evaluation Model size is an easy way to measure explanation quality, but it is too simplistic. For example, a sparse model with features that are themselves not interpretable is still not a good explanation. There are more dimensions to interpretability: Model sparsity: How many features are being used by the explanation? Monotonicity: Is there a monotonicity constraint? Monotonicity means that a feature has a monotonic relationship with the target. If the feature increases, the target either always increases or always decreases, but never switches between increasing and decreasing. Uncertainty: Is a measurement of uncertainty part of the explanation? Interactions: Is the explanation able to include interactions of features? Cognitive processing time: How long does it take to understand the explanation? Feature complexity: What features were used for the explanation? PCA components are harder to understand than word occurrences, for example. Description length of explanation. "],
["explanation.html", "2.5 Human-style Explanations", " 2.5 Human-style Explanations Let’s dig deeper and discover what we humans accept as ‘good’ explanations and what the implications for interpretable machine learning are. Research from the humanities can help us to figure that out. Miller (2017) did a huge survey of publications about explanations and this Chapter builds on his summary. In this Chapter, I want to convince you of the following: As an explanation for an event, humans prefer short explanations (just 1 or 2 causes), which contrast the current situation with a situation where the event would not have happened. Especially abnormal causes make good explanations. Explanations are social interactions between the explainer and the explainee (receiver of the explanation) and therefore the social context has a huge influence on the actual content of the explanation. If you build the explanation system to get ALL the factors for a certain prediction or behaviour, you do not want a human-style explanation, but rather a complete causal attribution. You probably want a causal attribution when you are legally required to state all influencing features or if you are debugging the machine learning model. In this case, ignore the following points. In all other setting, where mostly lay persons or people with little time are the recipients of the explanation, follow the advice here. 2.5.1 What is an explanation? An explanation is the answer to a why-question (Miller 2017). Why did the treatment not work on the patient? Why was my loan rejected? Why haven’t we been contacted by alien life yet? The first two kind of questions can be answered with an “everyday”-explanation, while the third one is from the category “More general scientific phenomena and philosophical questions”. We focus on the “everyday”-type explanation, because this is relevant for interpretable machine learning. Questions starting with “how” can usually be turned into “why” questions: “How was my loan rejected?” can be turned into “Why was my loan rejected”. The term “explanation” means the social and cognitive process of explaining, but it’s also the product of these processes. The explainer can be a human or a machine 2.5.2 What is a “good” explanation? Now that we know what an explanation is, the question arises, what a good explanation is. “Many artificial intelligence and machine learning publications and methods claim to be about ‘interpretable’ or ‘explainable’ methods, yet often this claim is only based on the authors intuition instead of hard facts and research.” - Miller (2017) Miller (2017) summarises what a ‘good’ explanation is, which this Chapter replicates in condensed form and with concrete suggestions for machine learning applications. Explanations are contrastive (Liptopn 2016): Humans usually don’t ask why a certain prediction was made, but rather why this prediction was made instead of another prediction. We tend to think in counterfactual cases, i.e. “How would the prediction have looked like, if input X were different?”. For a house value prediction, a person might be interested in why the predicted price was high compared to the lower price she expected. When my loan application is rejected, I am not interested what in general constitutes a rejection or an approval. I am interested in the factors of my application that would need to change so that it got accepted. I want to know the contrast between my application and the would-be-accepted version of my application. The realisation that contrastive explanations matter, is an important finding for explainable machine learning. As we will see, most interpretable models allow to extract some form of explanation that implicitly contrast it to an artificial data instance or an average of instances. A doctor who wonders: “Why did the treatment not work on the patient?”, might ask for an explanation contrastive to a patient, where the treatment worked and who is similar to the non-responsive patient. Contrastive explanations are easier to understand than complete explanations. A complete explanation to the doctor’s why question (why does the treatment not work) might include: The patient has the disease already since 10 years, 11 genes are over-expressed making the disease more severe, the patients body is very fast in breaking down the medication into ineffective chemicals , etc.. The contrastive explanation, which answers the question compared to the other patient, for whom the drug worked, might be much simpler: The non-responsive patient has a certain combination of genes, that make the medication much less effective, compared to the other patient. The best explanation is the one that highlights the greatest difference between the object of interest and the reference object. What it means for interpretable machine learning: Humans don’t want a complete explanation for a prediction but rather compare what the difference were to another instance’s prediction (could also be an artificial one). Making explanations contrastive is application dependent, because it requires a point of reference for comparison. And this might depend on the data point to be explained, but also on the user receiving an explanation. A user of a house price prediction website might want to have an explanation of a house price prediction contrastive to her own house or maybe to some other house on the website or maybe to an average house in the neighbourhood. The solution for creating contrastive explanations in an automated fashion might include finding prototypes or archetypes in the data to contrast to. Explanations are selected: People don’t expect explanations to cover the actual and complete list of causes of an event. We are used to selecting one or two causes from a huge number of possible causes as THE explanation. For proof, switch on the television and watch some news: “The drop in share prices is blamed on a growing backlash against the product due to problems consumers are reporting with the latest software update.”, “Tsubasa and his team lost the match because of a weak defence: they left their opponents to much free space to play out their strategy.”, “The increased distrust in established institutions and our government are the main factors that reduced voter turnout.” The fact that an event can be explained by different causes is called the Rashomon Effect. Rashomon is a Japanese movie in which alternative, contradictory stories (explanations) of a samurai’s death are told. For machine learning models it is beneficial, when a good prediction can be made from different features. Ensemble methods can combine multiple models with different features (different explanations) and thrive because averaging over those “stories” makes the predictions more robust and accurate. But it also means that there is no good selective explanation why they made the prediction. What it means for interpretable machine learning: Make the explanation very short, give only 1 to 3 reasons, even if the world is more complex. The LIME method does a good job with this. Explanations are social: They are part of a conversation or interaction between the explainer and the receiver of the explanation. The social context determines the content and type of explanations. If I wanted to explain why digital cryptocurrencies are worth so much, to a technical person I would say things like: “The decentralised, distributed blockchain-based ledger that cannot be controlled by a central entity resonates with people’s desire to secure their wealth, which explains the high demand and price.”. But to my grandma I might say: “Look Grandma: Cryptocurrencies are a bit like computer gold. People like and pay a lot for gold, and young people like and pay a lot for computer gold.” What it means for interpretable machine learning: Be mindful of the social setting of your machine learning application and of the target audience. Getting the social part of the machine learning model right depends completely on your specific application. Find experts from the humanities (e.g. psychologists and sociologists) to help you out. Explanations focus on the abnormal. People focus more on abnormal causes to explain events (Kahnemann 19817). These are causes, that had a small likelihood but happened anyways (counterfactual explanation). And removing these abnormal causes would have changed the outcome a lot. Humans consider these kinds of “abnormal” causes to be good explanations. An example (Štrumbelj and Kononenko (2011)8): Assume that we have a dataset of test situations between teachers and students. The teachers have the option to directly let students pass a course after they have given a presentation or they can ask additional questions to test the student’s knowledge, which determines if the student passes. This means we have one feature ‘teacher’-feature, which is either 0 (teacher does not test) or 1 (teacher does test). The students can have different levels of preparation (student feature), which translate to different probabilities of correctly answering the teacher’s question (in case she decides to test the student). We want to predict if a student will pass the course and explain our prediction. The chance to pass is 100% if the teacher does not ask additional questions, else the probability to pass is according to the student’s level of preparation and the resulting probability to correctly answer the questions. Scenario 1: The teacher asks the students additional questions most of the time (e.g. 95 out of 100 times). A student who did not study (10% chance to pass the questions part) was not among the lucky ones and gets additional questions, which he fails to correctly answer. Why did the student fail the course? We would say it was the student’s fault to not study. Scenario 2: The teacher rarely asks additional questions (e.g. 3 out of 100 times). For a student who did not learn for possible questions, we would still predict a high probability to pass the course, since questions are unlikely. Of course, one of the students did not prepare for the questions (resulting in a 10% chance to pass the questions). He is unlucky and the teacher asks additional questions, which the student cannot answer and he fails the course. What is the reason for failing? I’d argue that now, the better explanation is that the teacher did test the student, because it was unlikely that the teacher would test. The teacher feature had an abnormal value. What it means for interpretable machine learning: If one of the input features for a prediction was abnormal in any sense (like a rare category of a categorical feature) and the feature influenced the prediction, it should be included in an explanation, even if other ‘normal’ features have the same influence on the prediction as the abnormal one. An abnormal feature in our house price predictor example might be that a rather expensive house has three balconies. Even if some attribution method finds out that the three balconies contribute the same price difference as the above average house size, the good neighbourhood and the recent renovation, the abnormal feature “three balconies” might be the best explanation why the house is so expensive. Explanations are truthful. Good explanations prove to be true in reality (i.e. in other situations). But, disturbingly, this is not the most important factor for a ‘good’ explanation. For example selectiveness is more important than truthfulness. An explanation that selects only one or two possible causes can never cover the complete list of causes. Selectivity omits part of the truth. It’s not true that only one or two factors caused a stock market crash for example, but the truth is that there are millions of causes that influence millions of people to act in a way that caused a crash in the end. What it means for interpretable machine learning: The explanation should predict the event as truthfully as possible, which is sometimes called fidelity in the context of machine learning. So when we say that three balconies increase the price of a house, it should hold true for other houses as well (or at least for similar houses). To humans, fidelity is not as important for a good explanations as selectivity, contrast and the social aspect. Good explanations are coherent with prior beliefs of the explainee. Humans tend to ignore information that is not coherent with their prior beliefs. This effect is known as confirmation bias (Nickerson 19989). Explanations are not spared from this type of bias: People will tend to devalue or ignore explanations that do not cohere with their beliefs. This of course differs individually, but there are also group-based prior beliefs like political opinions. What it means for interpretable machine learning: Good explanations are consistent with prior beliefs. This one is hard to infuse into machine learning and would probably drastically compromise predictive accuracy. An example would be negative effects of house size for the predicted price of the house for a few of the houses, which, let’s assume, improves accuracy (because of some complex interactions), but strongly contradicts prior beliefs. One thing you can do is to enforce monotonicity constraints (a feature can affect the outcome only into one direction) or use something like a linear model that has this property. Good explanations are general and probable. A cause that can explain a lot of events is very general and could be considered as a good explanation. Note that this contradicts the fact that people explain things with abnormal causes. As I see it, abnormal causes beat general causes. Abnormal causes are, by definition, rare. So in the absence of some abnormal event, a general explanation is judged to be good by humans. Also keep in mind that people tend to judge probabilities of joint events incorrectly. (Joe is a librarian. Is it more likely that he is shy or that he is a shy person that loves reading books?). A good example is ‘The bigger a house the more expensive it is’, which is a very general, good explanation why houses are expensive or cheap. What it means for interpretable machine learning: Generality is easily measured by a feature’s support, which is the number of instances for which the explanation applies over the total number of instances. Kahneman, Daniel, and Amos Tversky. 1981. “The Simulation Heuristic.” STANFORD UNIV CA DEPT OF PSYCHOLOGY.↩ Štrumbelj, Erik, and Igor Kononenko. 2011. “A General Method for Visualizing and Explaining Black-Box Regression Models.” In International Conference on Adaptive and Natural Computing Algorithms, 21–30. Springer.↩ Nickerson, Raymond S. 1998. “Confirmation Bias: A Ubiquitous Phenomenon in Many Guises.” Review of General Psychology 2 (2). Educational Publishing Foundation: 175.↩ "],
["data.html", "Chapter 3 Datasets", " Chapter 3 Datasets Throughout the book all the models and techniques will be applied on real datasets, which are freely available online. We will be using different datasets for different tasks: classification, regression and text classification. "],
["bike-data.html", "3.1 Bike Sharing Counts (Regression)", " 3.1 Bike Sharing Counts (Regression) This dataset contains daily counts of bike rentals from bike sharing company Capital-Bikeshare in Washington D.C., along with weather and seasonal information. The data was kindly open sourced by Capital-Bikeshare and the folks from Fanaee-T and Gama (2013)10 have added the weather data and the seasonal information. The goal is to predict how many rental bikes will be out on the street given weather and day. The data can be downloaded from the UCI Machine Learning Repository. For the examples, new features were introduced and not all original features were used. Here is the list of features that were used: season : spring (1), summer (2), autumn (3), winter (4). holiday : Binary feature indicating if the day was a holiday (1) or not (0). yr: The year (2011 or 2012). days_since_2011: Number of days since the 01.01.2011 (the first day in the dataset). This feature was introduced to account for the trend, in this case that the bike rental service became more popular over time. workingday : Binary feature indicating if the day was a workingday (1) or weekend / holiday (0). weathersit : The weather situation on that day Clear, Few clouds, Partly cloudy, Cloudy Mist + Cloudy, Mist + Broken clouds, Mist + Few clouds, Mist Light Snow, Light Rain + Thunderstorm + Scattered clouds, Light Rain + Scattered clouds Heavy Rain + Ice Pallets + Thunderstorm + Mist, Snow + Fog temp : Temperature in degrees Celsius. hum: Relative humidity in percent (0 to 100). windspeed: Wind speed in km per hour. cnt: Count of total rental bikes including both casual and registered. The count was used as the target in the regression tasks. Fanaee-T, Hadi, and Joao Gama. 2013. “Event Labeling Combining Ensemble Detectors and Background Knowledge.” Progress in Artificial Intelligence. Springer Berlin Heidelberg, 1–15. doi:10.1007/s13748-013-0040-3.↩ "],
["spam-data.html", "3.2 YouTube Spam Comments (Text Classification)", " 3.2 YouTube Spam Comments (Text Classification) As an example for text classification we will be using 1956 comments from 5 different YouTube videos. Thankfully the authors that used this dataset in an article about spam classification made the data freely available (Alberto, Lochter, and Almeida 201511). The comments were collected through the YouTube API from five of the ten most viewed videos on YouTube in the first half of 2015. All of the 5 videos are music videos. One of them is “Gangnam Style” from Korean artist Psy. The other artists were Katy Perry, LMFAO, Eminem, and Shakira. You can flip through some of the comments. The comments had been hand labeled as spam or legitimate. Spam has been coded with a ‘1’ and legitimate comments with a ‘0’. CONTENT CLASS Huh, anyway check out this you[tube] channel: kobyoshi02 1 Hey guys check out my new channel and our first vid THIS IS US THE MONKEYS!!! I’m the monkey in the white shirt,please leave a like comment and please subscribe!!!! 1 just for test I have to say murdev.com 1 me shaking my sexy ass on my channel enjoy ^_^ 1 watch?v=vtaRGgvGtWQ Check this out . 1 Hey, check out my new website!! This site is about kids stuff. kidsmediausa . com 1 Subscribe to my channel 1 i turned it on mute as soon is i came on i just wanted to check the views… 0 You should check my channel for Funny VIDEOS!! 1 and u should.d check my channel and tell me what I should do next! 1 You can also go over to YouTube and have a look at the comment section. But please don’t get trapped in the YouTube hell, ending up watching videos about monkeys stealing and drinking cocktails from tourists on the beach. Also the Google Spam detector probably has changed a lot since 2015. Watch the view-record breaking video “Gangnam Style” here Alberto, Túlio C, Johannes V Lochter, and Tiago A Almeida. 2015. “Tubespam: Comment Spam Filtering on Youtube.” In Machine Learning and Applications (Icmla), 2015 Ieee 14th International Conference on, 138–43. IEEE.↩ "],
["cervical.html", "3.3 Risk Factors for Cervical Cancer (Classification)", " 3.3 Risk Factors for Cervical Cancer (Classification) The cervical cancer dataset contains indicators and risk factors for predicting if a woman will get cervical cancer. The features contain demographics (e.g. age), habits, and medical history. The data can be downloaded from the UCI Machine Learning repository and is described by K. Fernandes, Cardoso, and Fernandes (2017) 12. The subset of features, which are used in the examples are: Age in years Number of sexual partners First sexual intercourse (age in years) Number of pregnancies Smokes yes (1) or no (1) Smokes (years) Hormonal Contraceptives yes (1) or no (0) Hormonal Contraceptives (years) IUD: Intrauterine device yes (1) or no (1) IUD (years): Number of years with an intrauterine device STDs: Ever had a sexually transmitted disease? Yes (1) or no (0) STDs (number): Number of sexually transmitted diseases. STDs: Number of diagnosis STDs: Time since first diagnosis STDs: Time since last diagnosis Biopsy: Biopsy results “Healthy” or “Cancer”. Target outcome. As the biopsy serves as the gold standard for diagnosing cervical cancer, the classification task in this book used the biopsy outcome as the target. Missing values for each column were imputed by the mode (most frequent value), which is probably a bad solution, because the value of the answer might be correlated with the probability for a value being missing. There is probably a bias, because the questions are of a very private nature. But this is not a book about missing data imputation, so the mode imputation will suffice! Fernandes, Kelwin, Jaime S Cardoso, and Jessica Fernandes. 2017. “Transfer Learning with Partial Observability Applied to Cervical Cancer Screening.” In Iberian Conference on Pattern Recognition and Image Analysis, 243–50. Springer.↩ "],
["simple.html", "Chapter 4 Interpretable Models", " Chapter 4 Interpretable Models The most straightforward way to get to interpretable machine learning is to use only a subset of algorithms that create interpretable models. Very common model types of this group of interpretable models are: Linear regression model. Logistic regression. Decision trees. In the following chapters we will talk about these models. Not in detail, only the basics, because there are already a ton of books, videos, tutorials, papers and more material. We will focus on how to interpret the models. This chapter covers linear models, logistic regression, and decision trees in more detail. It also lists some more. All of the interpretable model types explained in this book are interpretable on a modular level, with the exception of the k-nearest neighbors method. The following table gives an overview over the interpretable model types and their properties. A model is linear if the association between features and target is modeled linearly. A monotonic model ensures that the relationship between a feature and the target outcome is always in the same direction over the whole range of the feature: an increase in the features value will consistently lead to either an increase or a decrease of the target outcome, but never both for this feature. Monotonicity is useful for the interpretation of a model, because it makes it easier to understand a relationship. Some models can automatically include interactions between the features for predicting the outcome. You can always include interactions into any kind of model by manually creating interaction features. This can be important for correctly predicting the outcome, but too many or too complex interactions can hurt interpretability. Some models only handle regression, some only classification, and some can manage to do both. You can use this table to choose a suitable interpretable model for your task (either regression (regr.) or classification (class.)): Algorithm Linear Monotone Interaction Task Linear models Yes Yes No Regr. Logistic regression No Yes No Class. Decision trees No No Yes Class. + Regr. RuleFit Yes No Yes Class. + Regr. Naive Bayes Yes Yes No Class.n k-nearest neighbours No No No Class. + Regr. Terminology Y is the target outcome. X are the features (also called variables, covariables, covariates, or inputs). \\(\\beta\\) are regression weights (also called coefficients). "],
["limo.html", "4.1 Linear Model", " 4.1 Linear Model Linear models have been used for a long time by statisticians, computer scientists, and other people tackling quantitative problems. Linear models learn linear (and therefore monotonic) relationships between the features and the target. The linearity of the learned relationship makes the interpretation easy. Linear models can be used to model the dependency of a regression target \\(y\\) on \\(p\\) features \\(x\\). The learned relationships are linear and, for a singular instance \\(i\\), can be written as: \\[y_{i}=\\beta_{0}+\\beta_{1}x_{i1}+\\ldots+\\beta_{p}x_{ip}+\\epsilon_{i}\\] The i-th instance’s outcome is a weighted sum of its \\(p\\) features. The \\(\\beta_{j}\\) represent the learned feature weights or coefficients. The \\(\\epsilon_{i}\\) is the error we are still making, i.e. the difference between the predicted outcome and the actual outcome. Different methods can be used to estimate the optimal weight vector \\(\\hat{\\boldsymbol{\\beta}}\\). The ordinary least squares method is commonly used to find the weights that minimise the squared difference between the actual and the estimated outcome: \\[\\hat{\\boldsymbol{\\beta}}=\\arg\\!\\min_{\\beta_0,\\ldots,\\beta_p}\\sum_{i=1}^n\\left(y_i-\\left(\\beta_0+\\sum_{j=1}^p\\beta_jx_{ij}\\right)\\right)^{2}\\] We won’t go into detail about how the optimal weights can be found, but if you are interested you can read Chapter 3.2 of the book “Elements of Statistical Learning” (Hastie, Tibshirani, and Friedman 2009)13 or one of the other zillions of sources about linear regression models. The biggest advantage of linear regression models is their linearity: It makes the estimation procedure straightforward and, most importantly, these linear equations have an easy to understand interpretation on a modular level (i.e. the weights). That is one of the main reasons why the linear model and all similar models are so widespread in academic fields like medicine, sociology, psychology, and many more quantitative research fields. In these areas it is important to not only predict, e.g., the clinical outcome of a patient, but also to quantify the influence of the medication while at the same time accounting for things like gender, age, and other features in an interpretable manner. Linear regression models also come with some assumptions that make them easy to use and interpret but which are often not satisfied in reality. The assumptions are: Linearity, normality, homoscedasticity, independence, fixed features, and absence of multicollinearity. Linearity: Linear regression models force the estimated response to be a linear combination of the features, which is both their greatest strength and biggest limitation. Linearity leads to interpretable models: linear effects are simple to quantify and describe (see also next chapter) and are additive, so it is easy to separate the effects. If you suspect interactions of features or a non-linear association of a feature with the target value, then you can add interaction terms and use techniques like regression splines to estimate non-linear effects. Normality: The target outcome given the features are assumed to follow a normal distribution. If this assumption is violated, then the estimated confidence intervals of the feature weights are not valid. Consequently, any interpretation of the features p-values is not valid. Homoscedasticity (constant variance): The variance of the error terms \\(\\epsilon_{i}\\) is assumed to be constant over the whole feature space. Let’s say you want to predict the value of a house given the living area in square meters. You estimate a linear model, which assumes that no matter how big the house, the error terms around the predicted response have the same variance. This assumption is often violated in reality. In the house example it is plausible that the variance of error terms around the predicted price is higher for bigger houses, since also the prices are higher and there is more room for prices to vary. Independence: Each instance is assumed to be independent from the next one. If you have repeated measurements, like multiple records per patient, the data points are not independent from each other and there are special linear model classes to deal with these cases, like mixed effect models or GEEs. Fixed features: The input features are seen as ‘fixed’, carrying no errors or variation, which, of course, is very unrealistic and only makes sense in controlled experimental settings. But not assuming fixed features would mean that you have to fit very complex measurement error models that account for the measurement errors of your input features. And usually you don’t want to do that. Absence of multicollinearity: Basically you don’t want features to be highly correlated, because this messes up the estimation of the weights. In a situation where two features are highly correlated (something like correlation &gt; 0.9) it will become problematic to estimate the weights, since the feature effects are additive and it becomes indeterminable to which of the correlated features to attribute the effects. 4.1.1 Interpretation The interpretation of a weight in the linear model depends on the type of the corresponding feature: Numerical feature: For an increase of the numerical feature \\(x_{j}\\) by one unit, the estimated outcome changes by \\(\\beta_{j}\\). An example of a numerical feature is the size of a house. Binary feature: A feature, that for each instance takes on one of two possible values. An example is the feature “House comes with a garden”. One of the values counts as the reference level (in some programming languages coded with 0), like “No garden”. A change of the feature \\(x_{j}\\) from the reference level to the other level changes the estimated outcome by \\(\\beta_{j}\\). Categorical feature with multiple levels: A feature with a fixed amount of possible values. An example is the feature “Flooring type”, with possible levels “carpet”, “laminate” and “parquet”. One solution to deal with many levels is to one-hot-encode them, meaning each level gets its own binary column. From a categorical feature with \\(l\\) levels, you only need \\(l-1\\) columns, otherwise the coding is overparameterised. The interpretation for each level is then according to the binary features. Some languages, like R, allow you to code categorical features in different ways, described here. Intercept \\(\\beta_{0}\\): The intercept is the feature weight for the constant feature, which is always 1 for all instances. Most software packages automatically add this feature for estimating the intercept. The interpretation is: Given all numerical features are zero and the categorical features are at the reference level, the estimated outcome of \\(y_{i}\\) is \\(\\beta_{0}\\). The interpretation of \\(\\beta_{0}\\) is usually not relevant, because instances with all features at zero often don’t make any sense, unless the features were standardised (mean of zero, standard deviation of one), where the intercept \\(\\beta_0\\) reflects the predicted outcome of an instance where all features are at their mean. Another important measurement for interpreting linear models is the \\(R^2\\) measurement. \\(R^2\\) tells you how much of the total variance of your target outcome is explained by the model. The higher \\(R^2\\) the better your model explains the data. The formula to calculate \\(R^2\\) is: \\(R^2=1-SSE/SST\\), where SSE is the squared sum of the error terms: \\[SSE=\\sum_{i=1}^n(y_i-\\hat{y}_i)^2\\] and SST is the squared sum of the data variance: \\[SST=\\sum_{i=1}^n(y_i-\\bar{y})^2\\] The SSE tells you how much variance remains after fitting the linear model, which is measured by looking at the squared differences between the predicted and actual target values. SST is the total variance of the target around the mean. So \\(R^2\\) tells you how much of your variance can be explained by the linear model. \\(R^2\\) ranges between 0 for models that explain nothing and 1 for models that explain all of the variance in your data. There is a catch, because \\(R^2\\) increases with the number of features in the model, even if they carry no information about the target value at all. So it is better to use the adjusted R-squared (\\(\\bar{R}^2\\)), which accounts for the number of features used in the model. Its calculation is \\[\\bar{R}^2=R^2-(1-R^2)\\frac{p}{n-p-1}\\], where \\(p\\) is the number of features and \\(n\\) the number of instances. It isn’t helpful to do interpretation on a model with very low \\(R^2\\) or \\(\\bar{R}^2\\), because basically the model is not explaining much of the variance, so any interpretation of the weights are not meaningful. 4.1.2 Interpretation Example In this example we use the linear model to predict the bike rentals on a day, given weather and calendrical information. For the interpretation we examine the estimated regression weights. The features are a mix of numerical and categorical features. The table shows for each feature the estimated weight and the standard error of the estimation: Weight estimate Std. Error (Intercept) 2399.4 238.3 seasonSUMMER 899.3 122.3 seasonFALL 138.2 161.7 seasonWINTER 425.6 110.8 holidayHOLIDAY -686.1 203.3 workingdayWORKING DAY 124.9 73.3 weathersitMISTY -379.4 87.6 weathersitRAIN/SNOW/STORM -1901.5 223.6 temp 110.7 7.0 hum -17.4 3.2 windspeed -42.5 6.9 days_since_2011 4.9 0.2 Interpretation of a numerical feature (‘Temperature’): An increase of the temperature by 1 degree Celsius increases the expected number of bikes by 110.7, given all other features stay the same. Interpretation of a categorical feature (‘weathersituation’)): The estimated number of bikes is -1901.5 lower when it is rainy, snowing or stormy, compared to good weather, given that all other features stay the same. Also if the weather was misty, the expected number of bike rentals was -379.4 lower, compared to good weather, given all other features stay the same. As you can see in the interpretation examples, the interpretations always come with the footnote that ‘all other features stay the same’. That’s because of the nature of linear models: The target is a linear combination of the weighted features. The estimated linear equation spans a hyperplane in the feature/target space (a simple line in the case of a single feature). The \\(\\beta\\) (weight) values specify the slope (gradient) of the hyperplane in each direction. The good side is that it isolates the interpretation. If you think of the features as knobs that you can turn up or down, it is nice to see what happens when you would just turn the knob for one feature. On the bad side of things, the interpretation ignores the joint distribution with other features. Increasing one feature, but not changing others, might create unrealistic, or at least unlikely, data points. 4.1.3 Interpretation templates The interpretation of the features in the linear model can be automated by using following text templates. Interpretation of a Numerical Feature An increase of \\(x_{k}\\) by one unit increases the expectation for \\(y\\) by \\(\\beta_k\\) units, given all other features stay the same. Interpretation of a Categorical Feature A change from \\(x_{k}\\)’s reference level to the other category increases the expectation for \\(y\\) by \\(\\beta_{k}\\), given all other features stay the same. 4.1.4 Visual parameter interpretation Different visualisations make the linear model outcomes easy and quick to grasp for humans. 4.1.4.1 Weight plot The information of the weights table (weight estimates and variance) can be visualised in a weight plot (showing the results from the linear model fitted before): FIGURE 4.1: Each row in the plot represents one feature weight. The weights are displayed as points and the 0.95 confidence intervals with a line around the points. A 0.95 confidence interval means that if the linear model would be estimated 100 times on similar data, in 95 out of 100 times, the confidence interval would cover the true weight, under the linear model assumptions (linearity, normality, homoscedasticity, independence, fixed features, absence of multicolinearity). The weight plot makes clear that rainy/snowy/stormy weather has a strong negative effect on the expected number of bikes. The working day feature’s weight is close to zero and the zero is included in the 95% interval, meaning it is not influencing the prediction significantly. Some confidence intervals are very short and the estimates are close to zero, yet the features were important. Temperature is such a candidate. The problem about the weight plot is that the features are measured on different scales. While for weather situation feature the estimated \\(\\beta\\) signifies the difference between good and rainy/storm/snowy weather, for temperature it signifies only an increase of 1 degree Celsius. You can improve the comparison by scaling the features to zero mean and unit standard deviation before fitting the linear model, to make the estimated weights comparable. 4.1.4.2 Effect Plot The weights of the linear model can be analysed more meaningfully when multiplied by the actual feature values. The weights depend on the scale of the features and will be different if you have a feature measuring some height and you switch from meters to centimetres. The weight will change, but the actual relationships in your data will not. It is also important to know the distribution of your feature in the data, because if you have a very low variance, it means that almost all instances will get a similar contribution from this feature. The effect plot can help to understand how much the combination of a weight and a feature contributes to the predictions in your data. Start with the computation of the effects, which is the weight per feature times the feature of an instance: \\(\\text{effect}_{i,j}=w_{j}x_{i,j}\\). The resulting effects are visualised with boxplots: A box in a boxplot contains the effect range for half of your data (25% to 75% effect quantiles). The vertical line in the box is the median effect, i.e. 50% of the instances have a lower and the other half a higher effect on the prediction than the median value. The horizontal lines extend to\\(\\pm1.58\\text{IQR}/\\sqrt{n}\\), with IQR being the inter quartile range (\\(q_{0.75}-q_{0.25}\\)). The points are outliers. The categorical feature effects can be aggregated into one boxplot, compared to the weight plot, where each weight gets a row. FIGURE 4.2: The feature effect plot shows the distribution of the effects (= feature value times feature weight) over the dataset for each feature. The largest contributions to the expected number of bike rentals come from temperature and from the days feature, which captures the trend that the bike rental service became more popular over time. The temperature has a broad contribution distribution. The day trend feature goes from zero to large positive contribution, because the first day in the dataset (01.01.2011) gets a very low day effect, and the estimated weight with this feature is positive (4.93), so the effect increases with every day and is highest for the latest day in the dataset (31.12.2012). Note that for effects from a feature with a negative weight, the instances with a positive effect are the ones that have a negative feature value, so days with a high negative effect of windspeed on the bike rental count have the highest windspeeds. 4.1.5 Explaining Single Predictions How much did each feature of an instance contribute towards the prediction? This can, again, be answered by bringing together the weights and feature values of this instance and computing the effects. An interpretation of instance specific effects is only meaningful in comparison with the distribution of each feature’s effects. FIGURE 4.3: The effect for one instance shows the effect distribution while highlighting the effects of the instance of interest. Let’s have a look at the effect realisation for the rental bike count of one instance (i.e. one day). Some features contribute unusually little or much to the predicted bike count when compared to the overall dataset: Temperature (2 degrees) contributes less towards the predicted value compared to the average and the trend feature “days_since_2011” unusually much, because this instance is from late 2011 (5 days). 4.1.6 Coding Categorical Features There are several ways to encode a categorical feature and the choice influences the interpretation of the \\(\\beta\\)-weights. The standard in linear regression models is the treatment coding, which is sufficient in most cases. Using different codings boils down to creating different matrices (=design matrix) from your one column with the categorical feature. This section presents three different codings, but there are many more. The example used has six instances and one categorical feature with 3 levels. For the first two instances, the feature takes on category A, for instances three and four category B and for the last two instances category C. Treatment coding: The \\(\\beta\\) per level is the estimated difference in \\(y\\) compared to the reference level. The intercept of the linear model is the mean of the reference group (given all other features stay the same). The first column of the design matrix is the intercept, which is always 1. Column two is an indicator whether instance \\(i\\) is in category B, column three is an indicator for category C. There is no need for a column for category A, because then the linear equation would be overspecified and no unique solution (= unique \\(\\beta\\)’s) can be found. Knowing that an instance is neither in category B or C is enough. Feature matrix: \\[\\begin{pmatrix}1&amp;0&amp;0\\\\1&amp;0&amp;0\\\\1&amp;1&amp;0\\\\1&amp;1&amp;0\\\\1&amp;0&amp;1\\\\1&amp;0&amp;1\\\\\\end{pmatrix}\\] Effect coding: The \\(\\beta\\) per level is the estimated \\(y\\)-difference from the level to the overall mean (again, given all other features are zero or the reference level). The first column is again used to estimate the intercept. The weight \\(\\beta_{0}\\) which is associated with the intercept represents the overall mean and \\(\\beta_{1}\\), the weight for column two is the difference between the overall mean and category B. The overall effect of category B is \\(\\beta_{0}+\\beta_{1}\\). The interpretation for category C is equivalent. For the reference category A, \\(-(\\beta_{1}+\\beta_{2})\\) is the difference to the overall mean and \\(\\beta_{0}-(\\beta_{1}+\\beta_{2})\\) the overall effect. Feature matrix: \\[\\begin{pmatrix}1&amp;-1&amp;-1\\\\1&amp;-1&amp;-1\\\\1&amp;1&amp;0\\\\1&amp;1&amp;0\\\\1&amp;0&amp;1\\\\1&amp;0&amp;1\\\\\\end{pmatrix}\\] Dummy coding: The \\(\\beta\\) per level is the estimated mean of \\(y\\) for each level (given all feature are at value zero or reference level). Note that the intercept was dropped here, so that a unique solution for the linear model weights can be found. Feature matrix: \\[\\begin{pmatrix}1&amp;0&amp;0\\\\1&amp;0&amp;0\\\\0&amp;1&amp;0\\\\0&amp;1&amp;0\\\\0&amp;0&amp;1\\\\0&amp;0&amp;1\\\\\\end{pmatrix}\\] If you want to dive a bit deeper into different encodings of categorical features, checkout this webpage and this blog post. 4.1.7 The disadvantages of linear models Linear models can only represent linear relationships. Each non-linearity or interaction has to be hand-crafted and explicitly given to the model as an input feature. Linear models are also often not that good regarding predictive performance, because the relationships that can be learned are so restricted and usually oversimplifies how complex reality is. The interpretation of a weight can be unintuitive because it depends on all other features. A feature with high positive correlation with the outcome \\(y\\) and another feature might get a negative weight in the linear model, because, given the other correlated feature, it is negatively correlated with \\(y\\) in the high-dimensional space. Completely correlated features make it even impossible to find a unique solution for the linear equation. An example: You have a model to predict the value of a house and have features like number of rooms and area of the house. House area and number of rooms are highly correlated: the bigger a house is, the more rooms it has. If you now take both features into a linear model, it might happen, that the area of the house is the better predictor and get’s a large positive weight. The number of rooms might end up getting a negative weight, because either, given that a house has the same size, increasing the number of rooms could make it less valuable or the linear equation becomes less stable, when the correlation is too strong. 4.1.8 Do linear models create good explanations? Judging by the attributes that constitute a good explanation as presented in this section, linear models don’t create the best explanations. They are contrastive, but the reference instance is a data point for which all continuous features are zero and the categorical features at their reference levels. This is usually an artificial, meaningless instance, which is unlikely to occur in your dataset. There is an exception: When all continuous features are mean centered (feature minus mean of feature) and all categorical features are effect coded, the reference instance is the data point for which each feature is at its mean. This might also be a non-existent data point, but it might be at least more likely or meaningful. In this case, the \\(\\beta\\)-values times the feature values (feature effects) explain the contribution to the predicted outcome contrastive to the reference mean-instance. Another aspect of a good explanation is selectivity, which can be achieved in linear models by using less features or by fitting sparse linear models. But by default, linear models don’t create selective explanations. Linear models create truthful explanations, as long as the linear equation can model the relationship between features and outcome. The more non-linearities and interactions exist, the less accurate the linear model becomes and the less truthful explanations it will produce. The linearity makes the explanations more general and simple. The linear nature of the model, I believe, is the main factor why people like linear models for explaining relationships. 4.1.9 Extending Linear Models Linear models have been extensively studied and extended to fix some of the shortcomings. Lasso is a method to “pressure” weights of irrelevant features to get an estimate of zero. Having unimportant features weighted by zero is useful, because having less terms to interpret makes the model more interpretable. Generalised linear models (GLM) allow the target outcome to have different distributions. The target outcome is not any longer required to be normally distributed given the features, but GLMs allow you to model for example Poisson distributed count variables. Logistic regression, is a GLM for categorical outcomes. Generalised additive models (GAMs) are GLMs with the additional ability to allow non-linear relationships with features, while maintaining the linear equation structure (sounds paradox, I know, but it works). You can also apply all sorts of tricks to go around some of the problems: Adding interactions: You can define interactions between features and add them as new features before estimating the linear model. The RuleFit algorithm can add interactions automatically. Adding non-linear terms like polynomials to allow non-linear relationships with features. Stratifying data by feature and fitting linear models on subsets. 4.1.10 Sparse linear models The examples for the linear models that I chose look all nice and tidy, right? But in reality you might not have just a handful of features, but hundreds or thousands. And your normal linear models? Interpretability goes downriver. You might even get into a situation with more features than instances and you can’t fit a standard linear model at all. The good news is that there are ways to introduce sparsity (= only keeping a few features) into linear models. 4.1.10.1 Lasso The most automatic and convenient way to introduce sparsity is to use the Lasso method. Lasso stands for “least absolute shrinkage and selection operator” and when added to a linear model, it performs feature selection and regularisation of the selected feature weights. Let’s review the minimization problem, the \\(\\beta\\)s optimise: \\[min_{\\boldsymbol{\\beta}}\\left(\\frac{1}{n}\\sum_{i=1}^n(y_i-x_i^T\\boldsymbol{\\beta})^2\\right)\\] Lasso adds a term to this optimisation problem: \\[min_{\\boldsymbol{\\beta}}\\left(\\frac{1}{n}\\sum_{i=1}^n(y_i-x_i^T\\boldsymbol{\\beta})^2+\\lambda||\\boldsymbol{\\beta}||_1\\right)\\] The term \\(||\\boldsymbol{\\beta}||_1\\), the L1-norm of the feature vector, leads to a penalisation of large \\(\\boldsymbol{\\beta}\\)-values. Since the L1-norm is used, many of the weights for the features will get an estimate of 0 and the others are shrunk. The parameter \\(\\lambda\\) controls the strength of the regularising effect and is usually tuned by doing cross-validation. Especially when \\(\\lambda\\) is large, many weights become 0. 4.1.10.2 Other Methods for Sparsity in Linear Models A big spectrum of methods can be used to reduce the number of features in a linear model. Methods that include a pre-processing step: Hand selected features: You can always use expert knowledge to choose and discard some features. The big drawback is, that it can’t be automated and you might not be an expert. Use some measures to pre-select features: An example is the correlation coefficient. You only take features into account that exceed some chosen threshold of correlation between the feature and the target. Disadvantage is that it only looks at the features one at a time. Some features might only show correlation after the linear model has accounted for some other features. Those you will miss with this approach. Step-wise procedures: Forward selection: Fit the linear model with one feature. Do that with each feature. Choose the model that works best (for example decided by the highest R squared). Now again, for the remaining features, fit different versions of your model by adding each feature to your chosen model. Pick the one that performs best. Continue until some criterium is reached, like the maximum number of features in the model. Backward selection: Same as forward selection, but instead of adding features, start with the model that includes all features and try out which feature you have to remove to get the highest performance increase. Repeat until some stopping criterium is reached. I recommend using Lasso, because it can be automated, looks at all features at the same time and can be controlled via \\(\\lambda\\). It also works for the logistic regression model for classification. Hastie, T, R Tibshirani, and J Friedman. 2009. The elements of statistical learning. http://link.springer.com/content/pdf/10.1007/978-0-387-84858-7.pdf.↩ "],
["logistic.html", "4.2 Logistic Regression", " 4.2 Logistic Regression Logistic regression is the linear regression model made fit for classification problems. 4.2.1 What’s Wrong with Linear Regression Models for Classification? The linear regression model works well in regression setups, but fails in the classification case. Why is that? In case of two classes, you could label one of the classes with 0 and the other with 1 and use a linear model on it and it would estimate the weights for you. There are just a few problems with that approach: A linear model does not output probabilities, but it treats the classes as numbers (0 and 1) and fits the best hyperplane (if you have one feature, it’s a line) that minimises the distances between the points and the hyperplane. So it simply interpolates between the points, but there is no meaning in it and you cannot interpret it as probabilities. Also a linear model will extrapolate the features and give you values below zero and above one, which are not meaningful and should tell you that there might be a more clever approach to classification. Since the predicted outcome is not a probability but some linear interpolation between points there is no meaningful threshold at which you can distinguish one class from the other. A good illustration of this issue was given on Stackoverflow Linear models don’t extend to classification problems with multiple classes. You would have to start labeling the next class with a 2, then 3 and so on. The classes might not have any meaningful order, but the linear model would force a weird structure on the relationship between the features and your class predictions. So for a feature with a positive weight, the higher the value of that feature the more it contributes to the prediction of a class with a higher number, even if classes that happened to get a similar number are not related at all. FIGURE 4.4: An illustration why linear regression does not work well in a binary classification setting. A linear model is fitted on artificial data for classifying a tumour as malignant (1) or benign (0), dependant on the size of the tumour. Each point is a tumour, the x-axis shows the size of the tumour, the y-axis the malignancy, points are slightly jittered to reduce over-plotting. The lines display the fitted curve from a linear model. In the data setting on the left, we can use 0.5 as a threshold for the predicted outcome of the linear model for separating benign from malignant tumours. After introducing a few more malignant tumour cases, especially with larger tumour sizes, the regression line shifts and a threshold of 0.5 does not separate the classes any longer. 4.2.2 Logistic Regression A solution for classification is logistic regression. Instead of fitting a straight line or hyperplane, the logistic regression model uses a non-linear function, the logistic function to squeeze the output of a linear equation between 0 and 1. The logistic function is defined as: \\[\\text{logistic}(\\eta)=\\frac{1}{1+exp(-\\eta)}\\] And it looks like this: FIGURE 4.5: The logistic function. It only outputs numbers between 0 and 1. At input 0 it outputs 0.5. The step from linear regression models to logistic regression is kind of straightforward. In the linear regression model we modelled the relationship between the outcome and the features with a linear equation: \\[\\hat{y}_{i}=\\beta_{0}+\\beta_{1}x_{i,1}+\\ldots+\\beta_{p}x_{i,p}\\] For the classification we prefer probabilities, which are between 0 and 1, so we wrap the right side of the equation into the logistic regression function and like that force the output to only take on values between 0 and 1. \\[P(y_{i}=1)=\\frac{1}{1+exp(-(\\beta_{0}+\\beta_{1}x_{i,1}+\\ldots+\\beta_{p}x_{i,p}))}\\] Let’s revisit the tumour size example again. But instead of the linear regression model, we use the logistic regression model: FIGURE 4.6: The logistic regression model successfully finds the correct decision boundary to distinguish between malignant and benign tumours dependent on the size of the tumour in this example. The blue line is the logistic function shifted and squeezed so that it fits the data. It works better with logistic regression and we can use 0.5 as a threshold in both cases. Including the additional points does not affect the estimated curve much. 4.2.3 Interpretation The interpretation of the logistic regression weights differs from the linear regression case, because in logistic regression the outcome is a probability between 0 and 1, and the weights don’t affect the probability linearly, but are squeezed through the logistic function. That’s why we need to reformulate the equation for the interpretation, so that there is only the linear term left on the right side of the formula. \\[log\\left(\\frac{P(y_{i}=1)}{1-P(y_{i}=1)}\\right)=log\\left(\\frac{P(y_{i}=1)}{P(y_{i}=0)}\\right)=\\beta_{0}+\\beta_{1}x_{i,1}+\\ldots+\\beta_{p}x_{i,p}\\] We call the inner term odds (probability of event divided by probability of no event): \\[\\frac{P(y_{i}=1)}{1-P(y_{i}=1)}\\] and wrapped in the logarithm it is called log odds: \\[log\\left(\\frac{P(y_{i}=1)}{1-P(y_{i}=1)}\\right)\\] So with a logistic regression model we have a linear model for the log odds. Great! Doesn’t sound helpful! Well, with a bit of shuffling again, you can find out how the prediction changes, when one of the features \\(x_j\\) is changed by 1 point. For this we can first apply the \\(exp()\\) function on both sides of the equation: \\[\\frac{P(y_{i}=1)}{(1-P(y_{i}=1))}=odds_i=exp\\left(\\beta_{0}+\\beta_{1}x_{i,1}+\\ldots+\\beta_{p}x_{i,p}\\right)\\] Then we compare what happens when we increase one of the \\(x_{i,j}\\) by 1. But instead of looking at the difference, we look at the ratio of the two predictions: \\[\\frac{odds_{i,x_j+1}}{odds_i}=\\frac{exp\\left(\\beta_{0}+\\beta_{1}x_{i,1}+\\ldots+\\beta_{j}(x_{i,j}+1)+\\ldots+\\beta_{p}x_{i,p}\\right)}{exp\\left(\\beta_{0}+\\beta_{1}x_{i,1}+\\ldots+\\beta_{j}x_{i,j}+\\ldots+\\beta_{p}x_{i,p}\\right)}\\] Using the rule that: \\[\\frac{exp(a)}{exp(b)}=exp(a-b)\\] and removing lots of terms gives us: \\[\\frac{odds_{i,x_j+1}}{odds_i}=exp\\left(\\beta_{j}(x_{i,j}+1)-\\beta_{j}x_{i,j}\\right)=exp\\left(\\beta_j\\right)\\] And we end up with something simple like \\(\\exp(\\beta_j)\\). So a change of \\(x_j\\) by one unit changes the odds ratio (multiplicatively) by a factor of \\(\\exp(\\beta_j)\\). We could also interpret it this way: A change in \\(x_j\\) by one unit changes the log odds ratio by \\(\\beta_j\\) units, but most people do the former because thinking about the \\(log()\\) of something is known to be hard on the brain. Interpreting the odds ratio already needs a bit of getting used to. For example if you have odds of 2, it means that the probability for \\(y_i=1\\) is twice as big as \\(y_i=0\\). If you have a \\(\\beta_j\\) (=odds ratio) of \\(0.7\\), then an increase in the respective \\(x_j\\) by one unit multiplies the odds by \\(\\exp(0.7)\\approx2\\) and the odds change to 4. But usually you don’t deal with the odds and only interpret the \\(\\beta\\)’s as the odds ratios. Because for actually calculating the odds you would need to set a value for each feature \\(x_j\\), which only makes sense if you want to look at one specific instance of your dataset. Here are the interpretations for the logistic regression model with different feature types: Numerical feature: For an increase of one unit of the feature \\(x_{j}\\), the estimated odds change (multiplicatively) by a factor of \\(\\exp(\\beta_{j})\\) Binary categorical feature: One of the two values of the feature is the reference level (in some languages the one that was coded in 0). A change of the feature \\(x_{j}\\) from the reference level to the other level changes the estimated odds (multiplicatively) by a factor of \\(\\exp(\\beta_{j})\\) Categorical feature with many levels: One solution to deal with many possible feature values is to one-hot-encode them, meaning each level gets its own column. From a categorical feature with L levels, you only need L-1 columns, otherwise it is over-parameterised. The interpretation for each level is then according to the binary features. Intercept \\(\\beta_{0}\\): Given all numerical features are zero and the categorical features are at the reference level, the estimated odds are \\(\\exp(\\beta_{0})\\). The interpretation of \\(\\beta_{0}\\) is usually not relevant. 4.2.4 Example We use the logistic regression model to predict cervical cancer given some risk factors. The following table shows the estimate weights, the associated odds ratios and the standard error of the estimates: TABLE 4.1: The results from fitting a logistic regression model on the cervical cancer dataset. Shown are the features used in the model, their estimated weights and according odds ratios and the standard errors of the estimated weights. Weight Odds ratio Std. Error Intercept 2.91 18.36 0.32 Hormonal contraceptives y/n 0.12 1.12 0.30 Smokes y/n -0.26 0.77 0.37 Num. of pregnancies -0.04 0.96 0.10 Num. of diagnosed STDs -0.82 0.44 0.33 Intrauterine device y/n -0.62 0.54 0.40 Interpretation of a numerical feature (‘Num. of diagnosed STDs’): An increase of the number of diagnosed STDs (sexually transmitted diseases) changes (decreases) the odds for cancer vs. no cancer multiplicatively by 0.44, given all other features stay the same. Keep in mind that correlation does not imply causation. No recommendation here to get STDs. Interpretation of a categorical feature (‘Hormonal contraceptives y/n’): For women with hormonal contraceptives, the odds for cancer vs. no cancer are by a factor of 1.12 higher, compared to women without hormonal contraceptives, given all other features stay the same. Again as in the linear models, the interpretations are always coming with the clause that ‘all other features stay the same’. "],
["tree.html", "4.3 Decision Tree", " 4.3 Decision Tree Linear regression models and logistic regression fail in situations where the relationship between features and outcome is non-linear or where the features are interacting with each other. Time to shine for the decision trees! Tree-based models split the data according to certain cutoff values in the features multiple times. Splitting means that different subsets of the dataset are created, where each instance belongs to one subset. The final subsets are called terminal or leaf nodes and the intermediate subsets are called internal nodes or split nodes. For predicting the outcome in each leaf node, a simple model is fitted with the instances in this subset (for example the subsets average target outcome). Trees can be used for classification and regression. There are a lot of tree algorithms with different approaches for how to grow a tree. They differ in the possible structure of the tree (e.g. number of splits per node), criteria for how to find the splits, when to stop splitting and how to estimate the simple models within the leaf nodes. Classification and regression trees (CART) is one of the more popular algorithms for tree induction. We will focus on CART, but the interpretation is similar for most of the tree types. I recommend the book ‘The elements of statistical learning’ (Hastie, Tibshirani, and Friedman 2009)14 for a more detailed introduction. FIGURE 4.7: Decision tree with artificial data. Instances with a value bigger than 3 for feature x1 end up in node 5. All other instances are assigned to node 3 or node 4, depending whether feature x2 values exceed 1. The following formula describes the relationship between outcome \\(y\\) and the features \\(x\\). \\[\\hat{y}_i=\\hat{f}(x_i)=\\sum_{m=1}^Mc_m{}I\\{x_i\\in{}R_m\\}\\] Each instance \\(x_i\\) falls into exactly one leaf node (=subset \\(R_m\\)). \\(I_{\\{x_i\\in{}R_m\\}}\\) is the identity function which returns 1 if \\(x_i\\) is in the subset \\(R_m\\) and else 0. If \\(x_i\\) falls into a leaf node \\(R_l\\), the predicted outcome is \\(\\hat{y}=c_l\\), where \\(c_l\\) is the mean of all the training instances in leaf node \\(R_l\\). But where do the subsets come from? This is quite simple: The algorithm takes a feature and tries which cut-off point minimises the sum of squares of \\(y\\) for a regression tasks or the Gini index of the class distribution of \\(y\\) for classification tasks. The best cut-off point makes the two resulting subsets as different as possible in terms of the target outcome. For categorical features the algorithm tries to build subsets by trying different groupings of categories. After this was done for each feature, the algorithm looks for the feature with the best cut-off and chooses it to split the node into two new nodes. The algorithm continues doing this recursively in both of the new nodes until a stopping criterium is reached. Possible criteria are: A minimum number of instances that have to be in a node before the split or the minimum number of instances that have to be in a terminal node. 4.3.1 Interpretation The interpretation is simple: Starting from the root node you go to the next nodes and the edges tell you which subsets you are looking at. Once you reach the leaf node, the node tells you the predicted outcome. All the edges are connected by ‘AND’. Template: If feature x is [smaller/bigger] than threshold c AND …, then the predicted outcome is \\(\\hat{y}_{\\text{leafnode}}\\). 4.3.2 Interpretation Example Let’s have a look again at the bike rental data. We want to predict the number of bike rentals on a given day. The learned tree visualized: FIGURE 4.8: Regression tree fitted on the bike rental data. The maximally allowed depth for the tree was set to 2. The features picked for the tree splits were the trend feature (days since 2011) and the temperature (temp). The boxplots show the distribution of bike rentals in the terminal node. The first split and one of the second splits was done in the trend feature, which tells how many days passed since beginning of the data collection and covers the trend that the bike rental service became more popular over time. For days that came before the 105th day the predicted number of bike rentals is ca. 1800, between the 106th and 430th day it is around 3900. For days after the 430th day, depending on the temperature, the prediction is either 4600 (if below 12 degrees) or 6600 (if above 12 degrees). 4.3.3 Advantages The tree structure is perfectly suited to cover interactions between features in the data. The data also ends up in distinct groups, which are often easier to grasp than points on a hyperplane like in linear regression. The interpretation is arguably pretty straightforward. The tree structure also has a natural visualization, with its nodes and edges. Trees create good explanations as defined here. The tree structure automatically invites to think about predicted values for single instances in a counterfactual way: “If feature \\(x_j\\) would have been bigger / smaller than the split point, the prediction would have been \\(\\hat{y}_{1}\\) instead of \\(\\hat{y}_2\\)” The created explanations are contrastive, because you can always compare the prediction of an instance with relevant (as defined by the tree) “what-if”-scenarios, which are simply the other leaf nodes of the tree. If the tree is short, like one to three splits deep, the resulting explanations are selective. A tree with a depth of three needs a maximum of three features and split points to create the explanation for the prediction of an instance. The truthfulness of the prediction depends on the predictive performance of the tree. The explanations for short trees are very simple and general, because for each split, the instance either falls into one or the other leave., and binary decisions are easy to understand. There is no need to transform features. In linear models it is sometimes necessary to take the logarithm of a feature. A decision tree can handle a feature regardless of monotonic transformations. 4.3.4 Disadvantages Handling of linear relationships, that’s what trees suck at. Any linear relationship between an input feature and the outcome has to be approximated by hard splits, which produces a step function. This is not efficient. This goes hand in hand with lack of smoothness. Slight changes in the input feature can have a big impact on the predicted outcome, which might not be desirable. Imagine a tree that predicts the value of a house and the tree splits in the square meters multiple times. One of the splits is at 100.5 square meters. Imagine a user of a house price estimator, that uses your decision tree model: She measures her house, concludes that the house has 99 square meters, types it into some nice web interface and get’s a prediction of 200 000 Euro. The user notices that she forgot to measure a small storeroom with 2 square meters. The storeroom has a skewed wall, so she is not sure if she can count it fully towards the whole house area or only half of the space. So she decides to try both 100.0 and 101.0 square meters. The results: 200 000 Euro and 205 000 Euro, which is quite unintuitive, because there was no change from 99 square meters to 100, but from 100 to 101. Trees are also quite unstable, so a few changes in the training dataset might create a completely different tree. That’s because each split depends on the parent split. And if a different feature gets selected as the first split feature, the whole tree structure will change. It does not generate confidence in the model if the structure flips so easily. Hastie, T, R Tibshirani, and J Friedman. 2009. The elements of statistical learning. http://link.springer.com/content/pdf/10.1007/978-0-387-84858-7.pdf.↩ "],
["decision-rules-if-then.html", "4.4 Decision Rules (IF-THEN)", " 4.4 Decision Rules (IF-THEN) A decision rule is a simple IF-THEN statement consisting of a condition (also called antecedent) and a prediction. For example: IF it rains today AND if it’s April (condition), THEN it will rain tomorrow (prediction). A single decision rule or a combination of several rules can be used to make predictions. Keywords: decision rules, decision sets, decision lists, association rules, IF-THEN rules Decision rules follow a general structure: IF the condition is true THEN make a particular prediction. Decision rules are probably the most interpretable prediction models. Their IF-THEN structure semantically resembles natural language and the way we think, provided that the condition is built from intelligible features, the length of the condition is short (number of \\(feature=value\\) pairs combined with an AND) and there are not too many rules. In programming it’s very natural to write IF-THEN rules. New in machine learning is that the decision rules are learned through an algorithm. Imagine using an algorithm to learn decision rules for predicting the value of a house (\\(low\\), \\(medium\\) or \\(high\\)). One decision rule learned by this model could be: If a house is bigger than 100 square meters and has a garden, then its value is high. More formally: IF \\(size&gt;100\\land{}garden=1\\) THEN \\(value=high\\). Sometimes decision rules are also written like this: \\((size&gt;100)\\land(garden=1)\\Rightarrow{}(value=high)\\). Let’s break down the decision rule: \\(size&gt;100\\) is the first condition in the IF-part. \\(garden=1\\) is the second condition in the IF-part. The two conditions are connected with an ‘AND’ to create a new condition. Both must be true for the rule to apply. The predicted outcome (THEN-part) is that \\(value=high\\). A decision rule uses at least one \\(feature=value\\) statement in the condition, with no upper limit on how many more can be added with an ‘AND’. An exception is the default rule that has no explicit IF-part and that applies when no other rule applies, but more about this later. How do we assess whether a particular decision rule makes sense? The usefulness of a decision rule is usually summarized in two numbers: Support and accuracy. Support (or coverage) of a rule: The percentage of instances to which the condition of a rule applies is called the support. Take for example the rule \\((size=big)\\land(location=good)\\Rightarrow(value=high)\\) for predicting house values. Suppose 100 of 1000 houses are big and in a good location, then the support of the rule is 10%. The prediction (THEN-part) is not important for the calculation of support. Accuracy (or confidence) of a rule: The accuracy of a rule is a measure of how accurate the rule is in predicting the correct class for the instances to which the condition of the rule applies. For example: Let’s say of the 100 houses, where the rule \\((size=big)\\land(location=good)\\Rightarrow(value=high)\\) applies, 85 have \\(value=high\\), 14 \\(value=medium\\) and 1 \\(value=low\\), then the accuracy of the rule is 85%. Usually there is a trade-off between accuracy and support: By adding more features in the condition, we can achieve higher accuracy, but lose support. To create a good classifier for predicting the value of a house you might need to learn not only one rule, but maybe 10 or 20. Then things can get more complicated: Rules can overlap: What if I want to predict the value of a house and two or more rules apply and they give me contradictory predictions? No rule applies: What if I want to predict the value of a house and none of the rules apply? There are two main strategies for dealing with multiple rules: Decision lists (ordered) and decision sets (unordered). Both strategies imply different solutions to the problem of overlapping rules. A decision list introduces an order to the decision rules. If the condition of the first rule is true for an instance, we use the prediction of the first rule. If not, we go to the next rule and check if it is true and so on. Decision lists are one-sided decision trees, where the first rule is the root node and with each rule, the tree grows in one direction. Decision lists solve the problem of overlapping rules by only returning the prediction of the first rule in the list that applies. A decision set resembles a democracy of the rules, except that some rules might have a higher voting power. In a set, the rules are either mutually exclusive, or there is a strategy for resolving conflicts, such as majority voting, which may be weighted by the individual rule accuracies or other quality measures. Interpretability suffers potentially when several rules apply. Both decision lists and sets can suffer from the problem that no rule applies to an instance. This can be resolved by introducing a default rule. The default rule is the rule that applies when no other rule applies. The prediction of the default rule is often the most frequent class of the data points which are not covered by other rules. If a set or list of rules covers the entire feature space, we call it exhaustive. By adding a default rule, a set or list automatically becomes exhaustive. There are many ways to learn rules from data and this book is far from covering them all. This chapter shows you three of them. The algorithms are chosen to cover a wide range of general ideas for learning rules, so all three of them represent very different approaches. OneR learns rules from a single feature. OneR is characterized by its simplicity, interpretability and its use as a benchmark. Sequential covering is a general procedure that iteratively learns rules and removes the data points that are covered by the new rule. This procedure is used by many rule learning algorithms. Bayesian Rule Lists combine pre-mined frequent patterns into a decision list using Bayesian statistics. Using pre-mined patterns is a common approach used by many rule learning algorithms. Let’s start with the simplest approach: Using the single, best feature to learn rules. 4.4.1 Learn Rules from a Single Feature (OneR) The OneR algorithm is one of the simplest rule induction algorithm. From all the features, OneR selects the one that carries the most information about the outcome of interest and creates decision rules from this feature. Despite the name OneR, which stands for “One Rule”, the algorithm generates more than one rule: It’s actually one rule per unique feature value of the selected best feature. A better name would be OneFeatureRules. The algorithm is simple and fast: Discretize the continuous features by choosing appropriate intervals. For each feature \\(x_j\\): Create a cross table between the feature values and the (categorical) outcome. For each feature values of \\(x_j\\), create a rule which predicts the most frequent class of the instances that have this particular feature value (can be read from the cross table). Calculate the total error of the rules for feature \\(x_j\\). Select the feature with the smallest total error. OneR always covers all instances of the dataset, since it uses all levels of the selected feature. Missing values can be either treated as an additional feature value or be imputed beforehand. OneR can be considered as a decision tree with only one split. The split is not necessarily binary as in CART, but depends on the number of unique feature values. Let’s look at an example how the best feature is chosen by OneR. The following table shows an artificial dataset about houses with information about its value, location, size and whether pets are allowed. We are interested in learning a simple model to predict the value of a house. location size pets value good small yes high good big no high good big no high bad medium no medium good medium only cats medium good small only cats medium bad medium yes medium bad small yes low bad medium yes low bad small no low OneR creates the cross tables between each feature and the outcome: value=low value=medium value=high location=bad 3 2 0 location=good 0 2 3 value=low value=medium value=high size=big 0 0 2 size=medium 1 3 0 size=small 2 1 1 value=low value=medium value=high pets=no 1 1 2 pets=only cats 0 2 0 pets=yes 2 1 1 For each feature, we go through the table row by row: Each feature value is the IF-part of a rule; the most common class for instances with this feature value is the prediction, the THEN-part of the rule. For example, the size feature with the levels \\(small\\), \\(medium\\) and \\(big\\) results in three rules. For each feature we calculate the total error rate of the generated rules, which is the sum of the errors. The location feature has the possible values \\(bad\\) and \\(good\\). The most frequent value for houses in bad locations is \\(low\\) and when we use \\(low\\) as a prediction, we make two mistakes, because two houses have a \\(medium\\) value. The predicted price for houses in good locations is \\(high\\) and again we make two mistakes, because two houses have a \\(medium\\) value. The error we make by of using the location feature is 4/10, for the size feature it’s 3/10 and for the pet feature it’s 4/10 . The size feature produces the rules with the lowest error and will be used for the final OneR model: IF \\(size=small\\) THEN \\(value=small\\) IF \\(size=medium\\) THEN \\(value=medium\\) IF \\(size=big\\) THEN \\(value=high\\) OneR prefers features with many possible levels, because those features can overfit the target more easily. Imagine a dataset that contains only noise and no signal, which means that all features take on random values and have no predictive value for the target. Some features have more levels than others. The features with more levels can now more easily overfit. A feature that has a separate level for each instance from the data would perfectly predict the entire training dataset. A solution would be to split the data into training and validation sets, learn the rules on the training data and evaluate the total error for choosing the feature on the validation set. Ties are another issues, i.e. when two features result in the same total error. OneR solves ties by either taking the first feature with the lowest error or the one with the lowest p-value of a chi-squared test. Let’s try OneR with real data. We use the cervical cancer classification task to test the OneR algorithm. All continuous input features were divided into five intervals according to feature value frequency. The following rules are created: Age prediction (12.9,27.2] Healthy (27.2,41.4] Healthy (41.4,55.6] Healthy (55.6,69.8] Healthy (69.8,84.1] Healthy The age feature was chosen by OneR as the best predictive feature. Since \\(Cancer\\) is rare, for each rule the majority class and therefore the predicted label is always \\(Healthy\\), which is rather unhelpful. It does not make sense to use the label prediction in this unbalanced case. The cross table between the ‘Age’ intervals and \\(Cancer\\)/\\(Healthy\\) together with the percentage of women with cancer is more informative: # Cancer # Healthy P(Cancer) Age=(12.9,27.2] 26 477 0.05 Age=(27.2,41.4] 25 290 0.08 Age=(41.4,55.6] 4 31 0.11 Age=(55.6,69.8] 0 1 0.00 Age=(69.8,84.1] 0 4 0.00 But before you start interpreting anything: Since the prediction for every feature and every value is \\(Healthy\\), the total error rate is the same for all features. The ties in the total error are, by default, resolved by using the first feature from the ones with the lowest error rates (here, all features have 55/858, which happens to be the Age feature. OneR doesn’t support regression tasks directly. But we can turn a regression task into a classification task by cutting the continuous outcome into intervals. We use this trick to predict the number of bike rentals with OneR by cutting the number of bike rentals into its four quartiles (0-25%, 25-50%, 50-75% and 75-100%). The following table shows the selected feature after fitting the OneR model: mnth prediction JAN [22,3152] FEB [22,3152] MAR [22,3152] APR (3152,4548] MAY (5956,8714] JUN (4548,5956] JUL (5956,8714] AUG (5956,8714] SEP (5956,8714] OKT (5956,8714] NOV (3152,4548] DEZ [22,3152] The selected feature is the month. The month feature has (surprise!) 12 feature levels, which is more than most other features have. So there is a danger of overfitting. On the more optimistic side: the month feature can handle the seasonal trend (e.g. lower rental numbers in winter) and the predictions seem sensible. Now we move from the simple OneR algorithm to a more complex procedure using rules with more complex conditions consisting of several features: Sequential Covering. 4.4.2 Sequential Covering Sequential covering is a general procedure that repeatedly learns a single rule to create a decision list (or set) that covers the entire dataset rule by rule. Many rule-learning algorithms are variants of the sequential covering algorithm. This chapter introduces the main recipe and uses RIPPER, a variant of the sequential covering algorithm for the examples. The idea is simple: First, find a good rule that applies to some of the data points. Remove all data points which are covered by the rule, that is, each data point to which the condition applies, regardless of whether the points are classified correctly or not. Repeat the rule-learning and removal of covered points with the remaining points until no more points are left or another stop condition is met. The result is a decision list. This approach of repeated rule-learning and removal of covered data points is called ‘separate-and-conquer’. Suppose we already have an algorithm that can create a single rule that covers part of the data. The sequential covering algorithm for two classes (one positive, one negative) works like this: Start with an empty list of rules (\\(rlist\\)). Learn a rule \\(r\\). While the list of rules is below a quality threshold or some positive examples are not yet covered: Add rule \\(r\\) to \\(rlist\\). Remove all data points covered by rule \\(r\\). Learn another rule on the remaining data. Return the decision list. FIGURE 4.9: The covering algorithm works by sequentially covering the feature space with single rules and removing the data points that are already covered by those rules. The approach is called separate-and-conquer. For visualization purposes, the features x1 and x2 are continuous, but most rule learning algorithms require categorical features. For example: We have a task and dataset for predicting the values of houses from size, location and whether pets are allowed. We learn the first rule, which turns out to be: ‘If \\(size=big\\) and \\(location=good\\), then \\(value=high\\)’. Then we remove all big houses in good locations from the dataset. With the remaining data we learn the next rule: Maybe: ‘If \\(location=good\\), then \\(value=medium\\)’ (Note that this rule is learned on data without big houses in good locations, leaving only medium and small houses in good locations). For multi-class settings, the approach must be modified. First, the classes are ordered by increasing prevalence. The sequential covering algorithm starts with the least common class, learns a rule for it, removes all covered instances, then moves on to the second least common class and so on. The current class is always treated as the positive class and all classes with a higher prevalence as the negative class. The last class is the default rule. This is also referred to as one-versus-all strategy in classification. How do we learn a single rule? The OneR algorithm would be useless here, since it would always cover the whole feature space. But there are many other possibilities. One possibility is to learn a single rule from a decision tree with beam search: Learn a decision tree (with CART or another tree learning algorithm). Start at the root node and recursively select the purest node (e.g. with the lowest misclassification rate). The majority class of the node in which we end is used as the rule prediction; the path leading to that node is used as the rule condition. The following figure illustrates the beam search in a tree: FIGURE 4.10: Learning a rule by searching a path through a decision tree. A decision tree is grown to predict the target of interest. To extract a good rule, start at the root node, greedily and iteratively follow the path which locally produces the purest subset (e.g. with highest accuracy of target classes) and add all the split values to the rule condition. The prediction of the rule is the majority class of the node we land in. This example shows how we learn a rule for predicting the value of a house. We end up with: ‘If \\(location=good\\) and \\(size=big\\), then \\(value=high\\)’ (assuming high as the most common class in that terminal node). Learning a single rule is equivalent to a search problem, where the search space is the space of all possible rules. The goal of the search is to find the best rule according to some criteria. There are many different search strategies: hill-climbing, beam search, exhaustive search, best-first search, ordered search, stochastic search, top-down search, bottom-up search, … RIPPER (Repeated Incremental Pruning to Produce Error Reduction) by Cohen (1995)15 is a variant of the Sequential Covering algorithm. RIPPER is a bit more sophisticated and uses as post-processing phase (rule pruning) to optimize the decision list (or set). RIPPER can run in ordered or unordered mode and generate either a decision list or decision set. We will use RIPPER to predict our data examples. The RIPPER algorithm does not find a rule in the classification task for cervical cancer. When we use RIPPER on the regression task to predict bike rentals some rules are found. Since RIPPER only works for classification, the bike counts must be turned into a categorical outcome. I achieved this by cutting the bike counts into the quartiles. For example \\((4548, 5956)\\) is the interval covering predicted bike rentals between \\(4548\\) and \\(5956\\). The following table shows the learned rules. rules (days_since_2011 &gt;= 438) and (temp &gt;= 17) and (temp &lt;= 27) and (hum &lt;= 67) =&gt; cnt=(5956,8714] (days_since_2011 &gt;= 443) and (temp &gt;= 12) and (weathersit = GOOD) and (hum &gt;= 59) =&gt; cnt=(5956,8714] (days_since_2011 &gt;= 441) and (windspeed &lt;= 10) and (temp &gt;= 13) =&gt; cnt=(5956,8714] (temp &gt;= 12) and (hum &lt;= 68) and (days_since_2011 &gt;= 551) =&gt; cnt=(5956,8714] (days_since_2011 &gt;= 100) and (days_since_2011 &lt;= 434) and (hum &lt;= 72) and (workingday = WORKING DAY) =&gt; cnt=(3152,4548] (days_since_2011 &gt;= 106) and (days_since_2011 &lt;= 323) =&gt; cnt=(3152,4548] =&gt; cnt=[22,3152] The interpretation is simple: If the conditions apply, we predict the interval on the right hand side as the number of bike rentals . The last rule is the default rule that applies when none of the other rules apply to an instance. To predict a new instance, start at the top of the list and check whether a rule applies. When a condition matches, then the right hand side of the rule is the prediction for this instance. The default rule ensures that there is always a prediction. 4.4.3 Bayesian Rule Lists In this section I will show you another approach to learning a decision list, which follows this rough recipe: Pre-mine frequent patterns from the data that can be used as conditions for the decision rules. Learn a decision list from a selection of the pre-mined rules. A specific approach using this recipe is called Bayesian Rule Lists (Letham et. al, 2015)16 or BRL for short. BRL uses Bayesian statistics to learn decision lists from frequent patterns which are pre-mined with the FP-tree algorithm (Borgelt 2005)17 But let’s start slowly: Pre-mining of frequent patterns A frequent pattern is the frequent (co-)occurrence of feature values As a pre-processing step for the BRL algorithm, we use the features (we don’t need the target outcome in this step) and extract frequently occurring patterns from them. A pattern can be a single feature value (e.g. \\(\\text{size=medium}\\)) or a combination of feature values such as \\(\\text{size=medium}\\land\\text{location=bad}\\). The frequency of a pattern is measured with its support in the dataset: \\[Support(x_j=A)=\\frac{1}n{}\\sum_{i=1}^nI(x_{ji}=A)\\] where \\(x_j=A\\) is the feature value, \\(n\\) the number of data points in the dataset and \\(I\\) the indicator function that returns \\(1\\) if the feature \\(x_j\\) of the instance \\(i\\) has level \\(A\\) otherwise \\(0\\). In a dataset of house values, if 20% of houses have no balcony and 80% have one or more, then the support for the pattern \\(balcony=0\\) is 20%. Support can also be measured for combinations of feature values, for example for \\(\\text{balcony=0}\\land\\text{pets=allowed}\\). There are many algorithms to find such frequent patterns, for example Apriori or FP-Growth. Which you use doesn’t matter much, only the speed at which the patterns are found is different, but the resulting patterns are always the same. I’ll give you a rough idea of how the Apriori algorithm works to find frequent patterns. Actually the Apriori algorithm consists of two parts, where the first part finds frequent patterns and the second part builds association rules from them. For the BRL algorithm, we are only interested in the frequent patterns that are generated in the first part of Apriori. In the first step, the Apriori algorithm starts with all feature values that have a support greater than the minimum support defined by the user. If the user says that the minimum support should be 10% and only 5% of the houses have \\(size=big\\), we would remove that feature value and keep only \\(size=medium\\) and \\(size=big\\) as patterns. This does not mean that the houses are removed from the data, it just means that \\(\\text{size=big}\\) is not returned as frequent pattern. Based on frequent patterns with a single feature value, the Apriori algorithm iteratively tries to find combinations of feature values of increasingly higher order. Patterns are constructed by combining \\(feature=value\\) statements with a logical AND, e.g. \\(\\text{size=medium}\\land\\text{location=bad}\\). Generated patterns with a support below the minimum support are removed. In the end we have all the frequent patterns. Any subset of a frequent pattern is frequent again, which is called the apriori property. It makes sense intuitively: By removing a condition from a pattern, the reduced pattern can only cover more or the same number of data points (support), but not less. For example, if 20% of the houses are \\(\\text{size=medium}\\land\\text{location=good}\\), then the support of houses that are only \\(\\text{size=medium}\\) is 20% or greater. The apriori property is used to reduce the number of patterns to be inspected. Only in the case of frequent patterns we have to check patterns of higher order. Now we are done with pre-mining conditions for the Bayesian Rule List algorithm. But before we go into the details of BRL, I would like to hint at another way for rule-learning based on pre-mined patterns. Other approaches suggest including the outcome of interest into the frequent pattern mining process and also executing the second part of the Apriori algorithm that builds IF-THEN rules. Since the algorithm is unsupervised, the THEN-part also contains feature values we are not interested in. But we can filter by rules that have only the outcome of interest in the THEN-part. These rules already form a decision set, but it would also be possible to arrange, prune, delete or recombine the rules. In the BRL approach however, we work with the frequent patterns and learn the THEN-part and how to arrange the patterns into a decision list using Bayesian statistics. Learning Bayesian Rule Lists The goal of the BRL algorithm is to learn an accurate decision list using a selection of the pre-mined conditions, while prioritizing lists with few rules and short conditions. BRL addresses this goal by defining a distribution of decision lists with prior distributions for the length of conditions (preferably shorter rules) and the number of rules (preferably a shorter list). The posteriori probability distribution of lists, makes it possible to say how likely a decision list is, given assumptions of shortness and how well the list fits the data. Our goal is to find the list that maximizes this posterior probability. Since it’s not possible to find the exact best list directly from the distributions of lists, BRL suggests the following recipe: 1) Generate an initial decision list, which is randomly drawn from the priori distribution. 2) Iteratively modify the list by adding, switching or removing rules, ensuring that the resulting lists follow the posterior distribution of lists. 3) Select the decision list from the sampled lists with the highest probability according to the posteriori distribution. Let’s go over the algorithm more closely: The algorithm starts with pre-mining feature value patterns with the FP-Growth algorithm. BRL makes a number of assumptions about the distribution of the target and the distribution of the parameters that define the distribution of the target. (Well, that’s Bayesian statistic.) If you are unfamiliar with Bayesian statistics, don’t get too caught up in the following explanations. It’s important to know that the Bayesian approach is a way to combine existing knowledge or requirements (so-called priori distributions) while also adapting to the data. In the case of decision lists, the Bayesian approach makes sense, since the prior assumptions nudges the decision lists to be short with also short rules. The goal is to sample decision lists \\(d\\) from the posteriori distribution: \\[\\underbrace{p(d|x,y,A,\\alpha,\\lambda,\\eta)}_{posteriori}\\propto\\underbrace{p(y|x,d,\\alpha)}_{likelihood}\\cdot\\underbrace{p(d|A,\\lambda,\\eta)}_{priori}\\] where \\(d\\) is a decision list, \\(x\\) are the features, \\(y\\) is the target, \\(A\\) the set of pre-mined conditions, \\(\\lambda\\) the prior expected length of the decision lists, \\(\\eta\\) the prior expected number of conditions in a rule, \\(\\alpha\\) the prior pseudo-count for the positive and negative classes (best fixed at \\((1,1)\\)). \\[p(d|x,y,A,\\alpha,\\lambda,\\eta)\\] quantifies how probable a decision list is, given the observed data and the priori assumptions. This is proportional to the likelihood of the outcome \\(y\\) given the decision list and the data times the probability of the list given prior assumptions and the pre-mined conditions. \\[p(y|x,d,\\alpha)\\] is the likelihood of the observed \\(y\\), given the decision list and the data. BRL assumes that \\(y\\) is generated by a Dirichlet-Multinomial distribution. The better the decision list \\(d\\) explains the data, the higher the likelihood. \\[p(d|A,\\lambda,\\eta)\\] is the prior distribution of the decision lists. It multiplicatively combines a truncated Poisson distribution (parameter \\(\\lambda\\)) for the number of rules in the list and a truncated Poisson distribution (parameter \\(\\eta\\)) for the number of feature values in the conditions of the rules. A decision list has a high posterior probability if it explains the outcome \\(y\\) well and is also likely according to the prior assumptions. Estimations in Bayesian statistics are always a bit tricky, because we usually can’t directly calculate the correct answer, but we have to draw candidates, evaluate them and update our posteriori estimates (using the Markov chain Monte Carlo). For decision lists this is even more tricky, because we have to draw from the distribution of decision lists. The BRL authors propose to first draw an initial decision list and then iteratively modify it to generate samples of decision lists from the posterior distribution of the lists (a Markov chain of decision lists). The results are potentially dependent on the initial decision list, so it is advisable to repeat this procedure to ensure a great variety of lists (default in the software implementation is 10 times). The following recipe tells us how to draw an initial decision list: Pre-mine patterns with FP-Growth. Sample the length \\(m\\) for the list from a truncated Poisson distribution. For the default rule: Sample the Dirichlet-Multinomial distribution parameter \\(\\theta_0\\) of the target value (i.e. the rule that applies when nothing else applies). For decision list rule \\(j=1,\\ldots,m\\), do: Sample the length of the rule \\(l_j\\) (number of conditions) for rule \\(j\\) Sample a condition of length \\(l_j\\) from the pre-mined conditions. Sample the Dirichlet-Multinomial distribution parameter for the THEN-part (i.e. for the distribution of the target outcome given the rule) For each observation in the dataset: Find the rule from the decision list that applies first (top to bottom). Draw the predicted outcome from the probability distribution (Binomial) suggested by the rule that applies. The next step is to generate many new lists starting from this initial sample to obtain many samples from the posterior distribution of decision lists. The new decision lists are sampled by starting from the initial list and then randomly either moving a rule to a different position in the list or adding a rule to the current decision list from the pre-mined conditions or removing a rule from the decision list. Which of the rules is switched, added or deleted is chosen at random. At each step, the algorithm evaluates the posteriori probability of the decision list (mixture of accuracy and shortness). The Metropolis Hastings algorithm ensures that we sample decision lists that have a high posterior probability. This procedure provides us with many samples from the distribution of decision lists. The BRL algorithm selects the decision list of the samples with the highest posterior probability. That’s it with the theory, now let’s see the BRL method in action. The examples use a faster variant of BRL called Scalable Bayesian Rule Lists (SBRL) by Yang et. al (2016) 18. We use the SBRL algorithm to predict the risk for cervical cancer. I first had to discretize all input features for the SBRL algorithm to work. For this purpose I binned the continuous features based on the frequency of the values (by quantiles). We get the following rules: rules If {STDs=1} (rule[259]) then positive probability = 0.16049383 else if {Hormonal.Contraceptives..years.=[0,10)} (rule[82]) then positive probability = 0.04685408 else (default rule) then positive probability = 0.27777778 Note that we get sensible rules, since the prediction on the THEN-part is not the class outcome, but the predicted probability for cancer. The conditions were selected from patterns that were pre-mined with the FP-Growth algorithm. The following table displays the pool of conditions the SBRL algorithm could choose from for building a decision list. The maximum number of feature values in a condition I allowed as a user was two. Here is a sample of ten patterns: pre-mined conditions First.sexual.intercourse=[17.3,24.7),STDs=1 Hormonal.Contraceptives=0,STDs=0 Num.of.pregnancies=[0,3.67),STDs..Number.of.diagnosis=[0,1) Smokes=1 First.sexual.intercourse=[10,17.3) Smokes=1,STDs..Number.of.diagnosis=[0,1) STDs..number.=[1.33,2.67) Num.of.pregnancies=[3.67,7.33) Num.of.pregnancies=[3.67,7.33),IUD..years.=[0,6.33) Age=[13,36.7),STDs..Number.of.diagnosis=[1,2) Next, we apply the SBRL algorithm to the bike rental prediction task. This only works if the regression problem of predicting bike counts is converted into a binary classification task. I have arbitrarily created a classification task by creating a label that is 1 if the number of bike rentals exceeds 4000 bikes on a day, else 0. The following list was learned by SBRL: rules If {yr=2011,temp=[-5.22,7.35)} (rule[718]) then positive probability = 0.01041667 else if {yr=2012,temp=[7.35,19.9)} (rule[823]) then positive probability = 0.88125000 else if {yr=2012,temp=[19.9,32.5]} (rule[816]) then positive probability = 0.99253731 else if {season=SPRING} (rule[351]) then positive probability = 0.06410256 else if {yr=2011,temp=[7.35,19.9)} (rule[730]) then positive probability = 0.44444444 else (default rule) then positive probability = 0.79746835 Let’s predict the probability that the number of bike rentals will exceed 4000 for a day in 2012 with a temperature of 17 degrees Celsius. The first rule doesn’t apply, since it only applies for days in 2011. The second rule applies, because the day is in 2012 and 17 degrees lies in the interval \\([7.35,19.9)\\). Our prediction for the probability is 88%. 4.4.4 Advantages This section discusses the benefits of IF-THEN rules in general. IF-THEN rules are easy to interpret. They are probably the most interpretable of the interpretable models. This statement only applies if the number of rules is small, the conditions of the rules are short (maximum 3 I would say) and if the rules are organized in a decision list or a non-overlapping decision set. Decision rules can be as expressive as decision trees, while being more compact. Decision tree often also suffer from replicated sub-trees, that is, when the splits following a left and a right child node have the same structure. The prediction with IF-THEN rules is fast, since only a few binary statements need to be checked to determine which rules apply. Decision rules are robust against monotonous transformations of the input features, because only the threshold in the conditions changes. They are also robust against outliers, since it only matters if a condition applies or not. IF-THEN rules usually generate sparse models, which means that not many features are included. They select only the relevant features for the model. For example, a linear model assigns a weight to every input feature by default. Features that are irrelevant can simply be ignored by IF-THEN rules. Simple rules like from OneR can be used as baseline for more complex algorithms. 4.4.5 Disadvantages This section deals with the disadvantages of IF-THEN rules in general. The research and literature for IF-THEN rules focuses on classification and almost completely neglects regression. While you can always divide a continuous target into intervals and turn it into a classification problem, you always lose information. In general, approaches are more attractive if they can be used for both regression and classification. Often the features also have to be categorical. That means numeric features must be binned, if you want to use them. There are many ways to cut a continuous feature into intervals, but this is not trivial and comes with many questions without clear answers. How many intervals should the feature be divided into? What’s the splitting criteria: Fixed interval lengths, quantiles or something else? Dealing with binning continuous features is a non-trivial issue that is often neglected and people just use the next best method (like I did in the examples). Many of the older rule-learning algorithms are prone to overfitting. The algorithms presented here all have at least some safeguards to prevent overfitting: OneR is limited because it can only use one feature (only problematic if the feature has too many levels or if there are many features, which equates to the multiple testing problem), RIPPER does pruning and Bayesian Rule Lists impose a prior distribution on the decision lists. Decision rules are bad in describing linear relationships between features and output. That’s a problem they share with the decision trees. Decision trees and rules can only produce step-like prediction functions, where changes in the prediction are always jumps and never smooth curves. This is related to the issue that the inputs have to be categorical (in decision trees, they are implicitly categorized by splitting them). 4.4.6 Software and Alternatives OneR is implemented in the R package OneR, which was used for the examples in this book. OneR is also implemented in the Weka machine learning library and as such available in Java, R and Python. RIPPER is also implemented in Weka. For the examples, I used the R implementation of JRIP in the RWeka package. SBRL is available as R package (which I used for the examples), in Python or as C implementation. I won’t even try to list all alternatives for learning decision rule sets and lists, but will point to some summarizing work. I recommend the book ‘Foundations of Rule Learning’ from Fuernkranz et. al (2012)19. It’s an extensive work on learning rules, for those who want to delve deeper into the topic. It provides a holistic framework for thinking about learning rules and presents many rule learning algorithms. I also recommend to checkout the Weka rule learners, which implement RIPPER, M5Rules, OneR, PART and many more. IF-THEN rules can be used in linear models as described in this book in the chapter about the RuleFit algorithm. Cohen, W. (1995). Fast effective rule induction. Icml. Retrieved from http://www.inf.ufrgs.br/~alvares/CMP259DCBD/Ripper.pdf↩ Letham, B., Rudin, C., McCormick, T. H., &amp; Madigan, D. (2015). Interpretable classifiers using rules and bayesian analysis: Building a better stroke prediction model. Annals of Applied Statistics, 9(3), 1350–1371. https://doi.org/10.1214/15-AOAS848↩ Borgelt, C. (2005). An implementation of the FP-growth algorithm. Proceedings of the 1st International Workshop on Open Source Data Mining Frequent Pattern Mining Implementations - OSDM ’05, 1–5. http://doi.org/10.1145/1133905.1133907↩ Yang, H., Rudin, C., &amp; Seltzer, M. (2016). Scalable Bayesian Rule Lists, 31. Retrieved from http://arxiv.org/abs/1602.08610↩ Fuernkranz, J., Gamberger, D., &amp; Lavrač, N. (2012). Foundations of Rule Learning. Foundations of Rule Learning. https://doi.org/10.1007/978-3-540-75197-7_2↩ "],
["rulefit.html", "4.5 RuleFit", " 4.5 RuleFit The RuleFit algorithm (J. H. Friedman and Popescu 200820) fits sparse linear models which include automatically detected interaction effects in the form of binary decision rules. The standard linear model doesn’t account for interactions between the features. Wouldn’t it be convenient to have a model that is as simple and interpretable as linear models, but that also integrates feature interactions? RuleFit fills this gap. RuleFit fits a sparse linear model with the original features and also a set of new features which are decision rules. These new features capture interactions between the original features. RuleFit generates these features automatically from decision trees. Each path through a tree can be turned into a decision rule by combining the split decisions to a rule. The node predictions are thrown away and only the splits are used in the decision rules: FIGURE 4.11: 4 rules can be generated from a tree with 3 terminal nodes. Where do the decision trees come from? These are trees that are trained to predict the outcome of interest, so that the splits are meaningful for the task at hand and not arbitrary. Any algorithm that creates a lot of trees can be used for RuleFit, like a Random Forest for example. Each tree is disassembled into decision rules, which are used as additional features in a linear Lasso model. The RuleFit paper uses the Boston housing data for illustration: The goal is to predict the median house value in the Boston neighbourhood. One of the rules (read: features) generated by RuleFit: “if (number of rooms \\(&gt;6.64\\)) and (concentration of nitric oxide \\(&lt;0.67\\)) then \\(1\\) else \\(0\\)” RuleFit also comes with a feature importance measurement, which helps to identify linear terms and rules that are important for the prediction. The feature importance is calculated from the weights of the regression model. The importance measure can be aggregated for the original features (which appear once untransformed and possibly in many decision rules). RuleFit also introduces partial dependence plots to plot the average change of the prediction by changing one feature. The partial dependence plot is a model-agnostic method, which can be used with any model, and it has its own part in the book. 4.5.1 Interpretation and Example Since RuleFit estimates a linear model in the end, the interpretation is equivalent to linear models. The only difference is that the model has new features that are coming from decision rules. Decision rules are binary features: A value of 1 means that all conditions of the rule are met, otherwise the value is 0. For linear terms in RuleFit, the interpretation is the same as in linear regression models: If \\(x_j\\) increases by one unit, the predicted outcome changes by \\(\\beta_j\\). In this example, we use RuleFit to predict the number of bike rentals on a given day. Some of the genereated rules for the bike rental prediction task are: The table shows five of the generated rules with their Lasso weights and importances (measured as a function of the weight, see later in the chapter) after fitting ‘RuleFit’ on the bike dataset: Description Weight Importance days_since_2011 &gt; 428 &amp; temp &gt; 5.199151 590 288 37.45835 &lt;= hum &lt;= 90.156225 -18 248 days_since_2011 &gt; 111 &amp; weathersit in (“GOOD”, “MISTY”) 598 228 temp &gt; 8.058349 &amp; weathersit in (“GOOD”, “MISTY”) 506 227 temp &gt; 13.228349 &amp; days_since_2011 &gt; 554 522 186 The most important rule was: “days_since_2011 &gt; 428 &amp; temp &gt; 5.199151” and the associated weight is 590.1. The interpretation is: If days_since_2011 &gt; 428 &amp; temp &gt; 5.199151, then the predicted number of bike rentals increases by 590.1, given all other features values stay fixed. In total, 335 such rules were created from the original 8 features. Quite a lot! But thanks to Lasso, only 29 of the 335 got a weight different from zero. Computing the global feature importances reveals that temperature and the time trend are the most important features: FIGURE 4.12: Feature importance measures for a RuleFit model predicting bike rentals. The most important features for the predictions were temperature and the time trend. The feature importance measurement includes the importance of the raw feature term and all the decision rules the feature appears in. 4.5.2 Guidelines In this section we will talk about the advantages and disadvantages of RuleFit and how to interpret it. Interpretation template The interpretation is analogue to linear models: The predicted outcome changes by \\(\\beta_j\\) if feature \\(x_j\\) changes by one unit, given all other features stay the same. The weight interpretation of a decision rule is a special case: If all conditions of a decision rule \\(r_k\\) apply, the predicted outcome changes by \\(\\alpha_k\\) (the learned weight for rule \\(r_k\\) in the linear model). And, respectively, for classification: If all conditions of decision rule \\(r_k\\) apply, the odds for event vs. no-event changes by a factor of \\(\\alpha_k\\). Advantages: RuleFit adds feature interactions automatically to linear models. Therefore it solves the problem of linear models that you have to add interaction terms manually and it helps a bit with the issue of modeling non-linear relationships. RuleFit can handle both classification and regression tasks. The created rules are easy to interpret, because they are binary decision rules. Either the rule applies to an instance or not. Good interpretability is only guaranteed as long as the number of conditions within a rule is not to big. A rule with 1 to 3 conditions seems reasonable to me. This translates into a maximum depth of 3 for the trees in the tree ensemble. Even if there are many rules in the model, they do not apply to each instance, so for one instance only a handful of rules are important (non-zero weights). This improves local interpretability. The RuleFit proposes a bunch of useful diagnostic tools. These tools are model-agnostic, that’s why you will find them in the model-agnostic section: feature importance, partial dependence plots and feature interactions. Disadvantages: Sometimes RuleFit creates many rules which get a non-zero weight in the Lasso model. The interpretability degrades with higher number of features in the model. A promising solution is to force feature effects to be monotonic, meaning that an increase in a feature has to result in an increase of the predicted outcome. An anecdotal drawback: The papers claim good performance of RuleFit - often close to the predictive performance of Random Forests! - yet in the few cases where I personally tried it, the performance was disappointing. The end product of the RuleFit procedure is a linear model with additional fancy features (the decision rules). But since it is a linear model, the weight interpretation is still unintuitive (given all features are fixed, increasing feature \\(x_j\\) by one unit, increases the predicted outcome by \\(\\beta_j\\)). It gets a bit more tricky if you have overlapping rules: For example one decision rule (feature) for the bike prediction could be: “temp &gt; 15” and another rule could be “temp &gt; 10 &amp; weather=‘GOOD’”. When the weather is good and the temperature is above 10 degrees, the temperature is automatically also always bigger then 15, which means in the cases where the second rule applies, the first one also always applies. The interpretation of the estimated weight for the second rule is: ‘Given all other features are fixed, the predicted number of bikes increases by \\(\\beta_2\\)’. BUT, now it becomes really clear that the ‘all other feature fixed’ is problematic, because if rule 2 applies, also rule 1 applies and the interpretation is nonsensical. The RuleFit algorithm is implemented in R by Fokkema and Christoffersen (2017)21 and you can find a Python version on Github. 4.5.3 Theory Let’s dive deeper into the technicalities of the RuleFit algorithm. RuleFit consists of two components: The first component produces “rules” from decision trees and the second component fits a linear model with the original features and the new rules as input (hence the name “RuleFit”). It enables automatic integration of interactions between features into a linear model, while having the interpretability of a sparse linear model. Step 1: Rule generation How does a rule look like? The rules that the algorithm generates have a simple form: For example: “if \\(x2&lt;3\\) and \\(x5&lt;7\\) then \\(1\\) else \\(0\\)”. The rules are constructed by disassembling decision trees: Each path to a node in a tree can be turned into a decision rule. The trees used for the rules are fitted to predict the target outcome. The splits and resulting rules are optimised to predict the outcome you are interested in. You simply chain the binary decisions that lead to a certain node with a logical “AND”, and voilà, you have a rule. It is desirable to generate a lot of diverse and meaningful rules. Gradient boosting is used to fit an ensemble of decision trees (by regressing or classifying \\(y\\) with your original features \\(X\\)). Each resulting tree is turned into multiple rules. Not only boosted trees, but any type of ensemble of trees can be used to generate the trees for RuleFit: \\[f(x)=a_0+\\sum_{m=1}^M{}a_m{}f_m(X)\\] where \\(M\\) is the number of trees and \\(f_m(x)\\) represents the prediction function of the \\(m\\)-th tree. Bagged ensembles, Random forests, AdaBoost and MART yield ensemble of trees and can be used for RuleFit. From all of the trees of the ensemble, we produce the rules. Each rule \\(r_m\\) takes on the form: \\[r_m(x)=\\prod_{j\\in\\text{T}_m}I(x_j\\in{}s_{jm})\\] where \\(\\text{T}_{m}\\) is the set of features used in \\(m\\)-th tree, \\(I(\\cdot)\\) is the indicator function, which is 1 if the feature \\(x_j\\) is in the specified subset of values \\(s_{jm}\\) for \\(x_j\\) (as specified by the tree splits) and otherwise 0. For numerical features, \\(s_{jm}\\) is one to multiple intervals in the value range of the feature \\(x_j\\), depending on the number of splits in that feature. In case of a single split, the \\(s_{jm}\\) looks like one of the two cases: \\(x_{s_{jm},\\text{lower}}&lt;x_j\\) or \\(x_j&lt;x_{s_{jm},upper}\\). Further splits in that feature create more complicated intervals. For categorical features the subset \\(s_{jm}\\) contains some specific categories of \\(x_j\\). A made up example for the bike rental dataset: \\[r_{17}(x)=I(x_{\\text{temp}}&lt;15)\\cdot{}I(x_{\\text{weather}}\\in\\{\\text{good},\\text{cloudy}\\})\\cdot{}I(10\\leq{}x_{\\text{windspeed}}&lt;20)\\] This rule will only be equal to 1 if all of the three conditions are met, otherwise 0. RuleFit extracts all possible rules from a tree, not only from the leaf nodes. So another rule that would be created is: \\[r_{18}(x)=I(x_{\\text{temp}}&lt;15)\\cdot{}I(x_{\\text{weather}}\\in\\{\\text{good},\\text{cloudy}\\}\\] In total, \\[K=\\sum_{m=1}^M2(t_m-1)\\] rules are created from the ensemble of \\(M\\) trees, with \\(t_m\\) terminal nodes each. A trick that is introduced by the RuleFit authors is to fit trees with random depth, so that a lot of diverse rules are generated with different lengths. Note that we throw away the predicted value in each node and only keep the conditions that lead us to the node and create a rule from it. The weighting of the decision rules will happen in step 2 of fitting RuleFit. Another way to see the first step is, that it generates a new set of features out of your original features \\(X\\). Those features are binary and can represent quite complex interactions of your original \\(X\\). The rules are chosen to maximise the prediction task at hand. The rules are automatically generated from the covariates matrix X. You can see the rules simply as new features based on your original features. Step 2: Sparse linear model You will get A LOT of rules from the first step. Since the first step is only a feature transformation function on your original dataset you are still not done with fitting a model and also you want to reduce the number of rules. Next to the rules, also all your ‘raw’ features from your original dataset will be used in the Lasso linear model. Every rule and original feature becomes a feature in Lasso and gets a weight estimate. The original, raw features are added because trees suck at representing simple linear relationships between y and x. Before we put everything into Lasso to get a sparse linear model, we winsorise the original features, so that they are more robust against outliers: \\[l_j^*(x_j)=min(\\delta_j^+,max(\\delta_j^-,x_j))\\] where \\(\\delta_j^-\\) and \\(\\delta_j^+\\) are the \\(\\delta\\) quantiles of the data distribution of \\(x_j\\). A choice of \\(0.05\\) for \\(\\delta\\) means that every value of \\(x_j\\) that is in the 5% lowest or 5% highest values will be set to the values at 5% or 95% respectively. As a rule of thumb, you can choose \\(\\delta=0.025\\). In addition, the linear terms have to be normalised so that they have the same prior influence as a typical decision rule: \\[l_j(x_j)=0.4\\cdot{}l^*_j(x_j)/std(l^*_j(x_j))\\] The \\(0.4\\) is the average standard deviation of rules with a uniform support distribution \\(s_k\\sim{}U(0,1)\\). We combine both types of features to generate a new feature matrix and estimate a sparse linear model with Lasso, with the following structure: \\[\\hat{f}(x)=\\hat{\\beta}_0+\\sum_{k=1}^K\\hat{\\alpha}_k{}r_k(x)+\\sum_{j=1}^p\\hat{\\beta}_j{}l_j(x_j)\\] where \\(\\hat{\\alpha}\\) are the estimated weights for the rule features and \\(\\hat{\\beta}\\) for the original features. Since RuleFit uses Lasso, the loss function gets the additional constraint that forces some of the weights to get a zero estimate: \\[(\\{\\hat{\\alpha}\\}_1^K,\\{\\hat{\\beta}\\}_0^p)=argmin_{\\{\\hat{\\alpha}\\}_1^K,\\{\\hat{\\beta}\\}_0^p}\\sum_{i=1}^n{}L(y_i,f(x))+\\lambda\\cdot(\\sum_{k=1}^K|\\alpha_k|+\\sum_{j=1}^p|b_j|)\\] The outcome is a linear model that has linear effects for all of the original features and for the rules. The interpretation is the same as with linear models, the only difference is that some features are now binary rules. Step 3 (optional): Feature importance For the linear terms of the original features, the feature importance is measured with the standardised predictor: \\[I_j=|\\hat{\\beta}_j|\\cdot{}std(l_j(x_j))\\] where \\(\\beta_j\\) is the weight from the Lasso model and \\(std(l_j(x_j))\\) the standard deviation of the linear term over the data. For the decision rule terms, the importance is calculated with: \\[I_k=|\\hat{\\alpha}_k|\\cdot\\sqrt{s_k(1-s_k)}\\] where \\(\\hat{\\alpha}_k\\) is the associated Lasso weight of the decision rule and \\(s_k\\) is the support of the feature in the data, which is the percentage of data points for which the decision rule applies (where \\(r_k(x)=0\\)): \\[s_k=\\frac{1}{n}\\sum_{i=1}^n{}r_k(x_i)\\] A feature \\(x_j\\) occurs as a linear term and possibly also within many decision rules. How do we measure the total importance of the feature \\(x_j\\)? The importance \\(J_j(x)\\) of feature \\(x_j\\) can be measured at each individual prediction: \\[J_j(x)=I_l(x)+\\sum_{x_j\\in{}r_k}I_k(x)/m_k\\] where \\(I_l\\) is the importance of the linear term and \\(I_k\\) the importance of the decision rules in which \\(x_j\\) appears, and \\(m_k\\) is the number of features that constitute rule \\(r_k\\). Summing the feature importance over all instances gives us the global feature importance: \\[J_j(X)=\\sum_{i=1}^n{}J_j(x_i)\\] It is possible to choose a subset of instances and calculate the feature importance for this group. Friedman, Jerome H, and Bogdan E Popescu. 2008. “Predictive Learning via Rule Ensembles.” The Annals of Applied Statistics. JSTOR, 916–54.↩ Fokkema, Marjolein, and Benjamin Christoffersen. 2017. Pre: Prediction Rule Ensembles. https://CRAN.R-project.org/package=pre.↩ "],
["other-interpretable-models.html", "4.6 Other Interpretable Models", " 4.6 Other Interpretable Models The list of interpretable models is ever-growing and of unknown size. It contains simple models like linear models, decision trees and naive Bayes, but also more complex ones that combine or modify non-interpretable machine learning models to make them interpretable. Especially publications about the latter type of models are currently created with a high frequency and it is hard to keep up with the developments. We only tease a few additional ones in this chapter, especially the simpler and more established candidates. 4.6.1 Naive Bayes classifier The naive Bayes classifier makes use of the Bayes’ theorem of conditional probabilities. For each feature it computes the probability for a class given the value of the feature. The naive Bayes classifier does so for each feature independently, which is the same as having a strong (=naive) assumption of independence of the features. Naive Bayes is a conditional probability model and models the probability of a class \\(C_k\\) in the following way: \\[P(C_k|x)=\\frac{1}{Z}P(C_k)\\prod_{i=1}^n{}P(x_i|C_k)\\] The term \\(Z\\) is a scaling parameter that ensures that the probabilities for all classes sum up to 1. The probability of a class, given the features is the class probability times the probability of each feature given the class, normalized by \\(Z\\). This formula can be derived by using the Bayes’ theorem. Naive Bayes is an interpretable model, because of the independence assumption. It is interpretable on the modular level. For each classification it is very clear for each feature how much it contributes towards a certain class prediction. 4.6.2 K-Nearest Neighbours The k-nearest neighbour method can be used for regression and classification and uses the closest neighbours of a data point for prediction. For classification it assigns the most common class among the closest \\(k\\) neighbours of an instance and for regression it takes the average of the outcome of the neighbours. The tricky parts are finding the right \\(k\\) and deciding how to measure the distance between instances, which ultimately defines the neighbourhood. This algorithm is different from the other interpretable models presented in this book, since it is an instance-based learning algorithm. How is k-nearest neighbours interpretable? For starters, it has no parameters to learn, so there is no interpretability on a modular level, like in linear models. Also, it lacks global model interpretability, since the model is inherently local and there are no global weights or structures that are learned explicitly by the k-nearest neighbour method. Maybe it is interpretable on a local level? To explain a prediction, you can always retrieve the k-neighbours that were used for the prediction. If the method is interpretable solely depends on the question if you can ‘interpret’ a single instances in the dataset. If the dataset consists of hundreds or thousands of features, then it is not interpretable, I’d argue. But if you have few features or a way to reduce your instance to the most important features, presenting the k-nearest neighbours can give you good explanations. 4.6.3 And so many more … Many algorithms can produce interpretable models and not all can be listed here. If you are a researcher or just a big fan and user of a certain interpretable method, that is not listed here, get in touch with me and add the method to this book! "],
["agnostic.html", "Chapter 5 Model-Agnostic Methods", " Chapter 5 Model-Agnostic Methods Separating the explanations from the machine learning model (= model-agnostic interpretability methods) has some benefits (Ribeiro, Singh, and Guestrin 201622). The big advantage of model-agnostic interpretability methods over model-specific ones is their flexibility. The machine learning developer is free to use any machine learning model she likes, when the interpretability methods can be applied to any model. Anything that is build on top of an interpretation of a machine learning model, like a graphic or some user interface, also becomes independent of the underlying machine learning model. Usually not one but many types of machine learning models are evaluated for solving a task and if you compare the models in terms of interpretability, it is easier to do with model-agnostic explanations, because the same method can be used for any type of model. An alternative to model-agnostic interpretability methods is using only interpretable models, which often has the big disadvantage to usually loose accuracy compared to other machine learning models and locking you into one type of model and interpretability method. The other alternative is to use model-specific interpretability methods. The drawback here is also that it ties you to this one algorithm and it will be hard to switch to something else. Desirable aspects of a model-agnostic explanation system are (Ribeiro, Singh, and Guestrin 2016): Model flexibility: Not being tied to an underlying particular machine learning model. The method should work for random forests as well as deep neural networks. Explanation flexibility: Not being tied to a certain form of explanation. In some cases it might be useful to have a linear formula in other cases a decision tree or a graphic with feature importances. Representation flexibility: The explanation system should not have to use the same feature representation as the model that is being explained. For a text classifier that uses abstract word embedding vectors it might be preferable to use the presence of single words for the explanation. The bigger picture Let’s take a high level view on model-agnostic interpretability. We first abstract the world by capturing it by collecting data and abstract it further by learning the essence of the data (for the task) with a machine learning model. Interpretability is just another layer on top, that helps humans understand. FIGURE 5.1: The big picture of explainable machine learning. The real world goes through many layers before it reaches the human in the form of explanations. The bottom layer is the ‘World’. This could literally be nature itself, like the biology of the human body and how it reacts to medication, but also more abstract things like the real estate market. The ‘World’-layer contains everything that can be observed and is of interest. Ultimately we want to learn something about the ‘World’ and interact with it. The second layer is the ‘Data’-layer. We have to digitalise the ‘World’ in order to make it processable for computers and also to store information. The ‘Data’-layer contains anything from images, texts, tabular data and so on. By fitting machine learning models on top of the ‘Data’-layer we get the ‘Black Box Model’-layer. Machine learning algorithms learn with data from the real world to make predictions or find structures. On top of the ‘Black Box Model’-layer is the ‘Interpretability Methods’-layer that helps us deal with the opaqueness of machine learning models. What were the important features for a particular diagnosis? Why was a financial transaction classified as fraud? The last layer is occupied by a ‘Human’. Look! This one is waving at you because you are reading this book and you are helping to provide better explanations for black box models! Humans are the consumers of the explanations, ultimately. This layered abstraction also helps in understanding what the differences in approaches between statisticians and machine learning practitioners are. Statistician are concerned with the ‘Data’ layer, like planning clinical trials or designing surveys. They skip the ‘Black Box Model’-layer and go right to the ‘Interpretability Methods’-layer. Machine learning specialists are also concerned with the ‘Data’-layer, like collecting labeled samples of skin cancer images or crawling Wikipedia. Then comes the machine learning model. ‘Interpretability Methods’ is skipped and the human deals directly with the black box models prediction. It’s a nice thing, that in interpretable machine learning, the work of a statistician and a machine learner fuses and becomes something better. Of course this graphic does not capture everything: Data could come from simulations. Black box models also output predictions that might not even reach humans, but only feed other machines and so on. But overall it is a useful abstraction for understanding how (model-agnostic) interpretability becomes this new layer on top of machine learning models. Ribeiro, Marco Tulio, Sameer Singh, and Carlos Guestrin. 2016. “Model-Agnostic Interpretability of Machine Learning.” ICML Workshop on Human Interpretability in Machine Learning, no. Whi.↩ "],
["pdp.html", "5.1 Partial Dependence Plot (PDP)", " 5.1 Partial Dependence Plot (PDP) The partial dependence plot shows the marginal effect of a feature on the predicted outcome of a previously fit model (J. H. Friedman 200123). The prediction function is fixed at a few values of the chosen features and averaged over the other features. Other names: marginal means, predictive margins, marginal effects. A partial dependence plot can show if the relationship between the target and a feature is linear, monotonic or more complex. Applied to a linear regression model, partial dependence plots will always show a linear relationship, for example. The partial dependence function for regression is defined as: \\[\\hat{f}_{x_S}(x_S)=E_{x_C}\\left[\\hat{f}(x_S,x_C)\\right]=\\int\\hat{f}(x_S,x_C)d\\mathbb{P}(x_C)\\] The term \\(x_S\\) is the set of features for which the partial dependence function should be plotted and \\(x_C\\) are the other features that were used in the machine learning model \\(\\hat{f}\\). Usually, there are only one or two features in \\(x_S\\). Concatenated, \\(x_S\\) and \\(x_C\\) make up \\(x\\). Partial dependence works by marginalizing the machine learning model output \\(\\hat{f}\\) over the distribution of the features \\(x_C\\), so that the remaining function shows the relationship between the \\(x_S\\), in which we are interested, and the predicted outcome. By marginalizing over the other features, we get a function that only depends on features \\(x_S\\), interactions between \\(x_S\\) and other features included. The partial function \\(\\hat{f}_{x_S}\\) along \\(x_S\\) is estimated by calculating averages in the training data, which is also known as Monte Carlo method: \\[\\hat{f}_{x_S}(x_S)=\\frac{1}{n}\\sum_{i=1}^n\\hat{f}(x_S,x_{Ci})\\] In this formula, \\(x_{iC}\\) are actual feature values from the dataset for the features in which we are not interested and \\(n\\) is the number of instances in the dataset. One assumption made for the PDP is that the features in \\(x_C\\) are uncorrelated with the features in \\(x_S\\). If this assumption is violated, the averages, which are computed for the partial dependence plot, incorporate data points that are very unlikely or even impossible (see disadvantages). For classification, where the machine model outputs probabilities, the partial dependence function displays the probability for a certain class given different values for features \\(x_S\\). A straightforward way to handle multi-class problems is to plot one line or one plot per class. The partial dependence plot is a global method: The method takes into account all instances and makes a statement about the global relationship of a feature with the predicted outcome. 5.1.1 Examples In practice, the set of features \\(x_S\\) usually only contains one feature or a maximum of two, because one feature produces 2D plots and two features produce 3D plots. Everything beyond that is quite tricky. Even 3D on a 2D paper or monitor is already challenging. Let’s return to the regression example, in which we predict bike rentals. We first fit a machine learning model on the dataset, for which we want to analyse the partial dependencies. In this case, we fitted a RandomForest to predict the bike rentals and use the partial dependence plot to visualize the relationships the model learned. The influence of the weather features on the predicted bike counts: FIGURE 5.2: Partial dependence plots for the rental bike prediction model and different weather measurements (Temperature, Humidity, Windspeed). The biggest differences can be seen in the temperature: On average, the hotter the more bikes are rented, until 20C degrees, where it stays the same also for hotter temperatures and drops a bit again towards 30C degrees. The marks on the x-axis indicate the distribution of the feature in the data. For warm (but not too hot) weather, the model predicts a high number of bike rentals on average. The potential bikers are increasingly inhibited in engaging in cycling when humidity reaches above 60%. Also, the more wind the less people like to bike, which makes sense. Interestingly, the predicted bike counts don’t drop between 25 and 35 km/h windspeed, but there is just not so much training data, so we can’t be confident about the effect. At least intuitively I would expect the bike rentals to drop with any increase in windspeed, especially when the windspeed is very high. We also compute the partial dependence for cervical cancer classification. Again, we fit a RandomForest to predict whether a woman has cervical cancer given some risk factors. Given the model, we compute and visualize the partial dependence of the cancer probability on different features: FIGURE 5.3: Partial dependence plot of cancer probability and the risk factors age and number of years with hormonal contraceptives. For the age feature, the partial dependence plot shows that on average the cancer probability is until 40 and increases after that. The sparseness of data points after age of 50 indicates that the model did not have many data points to learn from above that age. The number of years on hormonal contraceptives is associated with a higher cancer risk after 10 years. But again, there are not many data points in that region, which implies that we might not be able to rely on the machine learning model predictions for &gt;10 years on contraceptives. We can also visualizes the partial dependence of two features at once: FIGURE 5.4: Partial dependence plot of cancer probability and the interaction of age and number of pregnancies. The plot shows the increase in cancer probability at 45, regardless of number of pregnancies. An interesting interaction happens at ages below 25: Young women who had 1 or 2 pregnancies have a lower predicted cancer risk, compared with women who had zero or above two pregnancies. The model predicts a - kind of - protective effect against cancer for 1 or 2 pregnancies. But be careful with drawing conclusions: This might just be a correlation and not causal! The cancer risk and number of pregnancies could be caused by another, unmeasured factor in which the young women differ. 5.1.2 Advantages The computation of partial dependence plots is intuitive: The partial dependence curve at a certain feature value represents the average prediction when we force all data points to take on that feature value. In my experience, laypersons usually grasp the idea of PDPs quickly. If the feature for which you computed the PDP is uncorrelated with the other model features, then the PDPs are perfectly representing how the feature influences the target on average. In this uncorrelated case the interpretation is clear: The partial dependence plots shows how on average the prediction changes in your dataset, when the j-th feature is changed. It’s complicated when features are correlated, see also disadvantages. Partial dependence plots are simple to implement. Causal interpretation : The calculation for the partial dependence plots has a causal interpretation: We intervene on \\(x_j\\) and measure the changes in the predictions. By doing this, we analyse the causal relationship between the feature and the outcome.24 The relationship is causal for the model - because we explicitly model the outcome on the feature - but not necessarily for the real world! 5.1.3 Disadvantages The maximum number of features you can look at jointly is - realistically - two and - if you are stubborn and pretend that 3D plots on a 2D medium are useful - three. That’s not the fault of PDPs, but of the 2-dimensional representation (paper or screen) and also our inability to imagine more than 3 dimensions. Some PD visualisations don’t include the feature distribution. Omitting the distribution can be misleading, because you might over-interpret the line in regions, with almost no feature values. This problem is easy to fix by showing a rug (indicators for data points on the x-axis) or a histogram. The assumption of independence poses the biggest issue. The feature(s), for which the partial dependence is computed, is/are assumed to be independently distributed from the other model features we average over. For example: Assume you want to predict how fast a person walks, given the person’s weight and height. For the partial dependence of one of the features, let’s say height, we assume that the other features (weight) are not correlated with height, which is obviously a wrong assumption. For the computation of the PDP at some height (for example at height = 200cm) we average over the marginal distribution of weight, which might include a weight below 50kg, which is unrealistic for a 2 meter person. In other words: When the features are correlated, we put weight on areas of the feature distribution where the actual probability mass is very low (for example it is unlikely that someone is 2 meters tall but weighting below 50kg). A solution to this problem are ALEPlots25, that only average over close data points. Heterogenous effects might be hidden because the PDP only shows the average over the observations. Assume that for feature \\(x_j\\) half your data points have a positive assocation with the outcome - the greater \\(x_j\\) the greater \\(\\hat{y}\\) - and the other half has negative assocation - the smaller \\(x_j\\) the greater \\(\\hat{y}\\). The PDP curve might be a straight, horizontal line, because the effects of both dataset halves cancel each other out. You then conclude that the feature has no effect on the outcome. By plotting the individiual conditional expectation curves instead of the aggregated line, we can uncover heterogeneous effects. Friedman, Jerome H. 2001. “Greedy Function Approximation: A Gradient Boosting Machine.” Annals of Statistics. JSTOR, 1189–1232.↩ Zhao, Q., &amp; Hastie, T. (2016). Causal interpretations of black-box models. Technical Report.↩ Apley, D. W. (n.d.). Visualizing the Effects of Predictor Variables in Black Box Supervised Learning Models, 1–36. Retrieved from https://arxiv.org/ftp/arxiv/papers/1612/1612.08468.pdf↩ "],
["ice.html", "5.2 Individual Conditional Expectation (ICE)", " 5.2 Individual Conditional Expectation (ICE) For a chosen feature, Individual Conditional Expectation (ICE) plots draw one line per instance, representing how the instance’s prediction changes when the feature changes. The partial dependence plot for visualizing the average effect of a feature is a global method, because it does not focus on specific instances, but on an overall average. The equivalent to a PDP for local expectations is called individual conditional expectation (ICE) plot (Goldstein et al. 2015[^Goldstein2015]). An ICE plot visualizes the dependence of the predicted response on a feature for EACH instance separately, resulting in multiple lines, one for each instance, compared to one line in partial dependence plots. A PDP is the average of the lines of an ICE plot. The values for a line (and one instance) can be computed by leaving all other features the same, creating variants of this instance by replacing the feature’s value with values from a grid and letting the black box make the predictions with these newly created instances. The result is a set of points for an instance with the feature value from the grid and the respective predictions. So, what do you gain by looking at individual expectations, instead of partial dependencies? Partial dependence plots can obfuscate a heterogeneous relationship that comes from interactions. PDPs can show you how the average relationship between feature \\(x_S\\) and \\(\\hat{y}\\) looks like. This works only well in cases where the interactions between \\(x_S\\) and the remaining \\(x_C\\) are weak. In case of interactions, the ICE plot will give a lot more insight. A more formal definition: In ICE plots, for each instance in \\(\\{(x_{S_i},x_{C_i})\\}_{i=1}^N\\) the curve \\(\\hat{f}_S^{(i)}\\) is plotted against \\(x_{S_i}\\), while \\(x_{C_i}\\) is kept fixed. 5.2.1 Example Let’s go back to the dataset about risk factors for cervical cancer and see how each instance’s prediction is associated with the feature ‘Age’. The model we will analyze is a RandomForest that predicts the probability of cancer for a woman given risk factors. In the partial dependence plot we have seen that the cancer probability increases around the age of 50, but does it hold true for each woman in the dataset? The ICE plot reveals that the most women’s predicted probability follows the average pattern of increase at 50, but there are a few exceptions: For the few women that have a high predicted probability at a young age, the predicted cancer probability does not change much with increasing age. FIGURE 5.5: Individual conditional expectation plot of cervical cancer probability by age. Each line represents the conditional expectation for one woman. Most women with a low cancer probability in younger years see an increase in predicted cancer probability, given all other feature value stay the same. Interestingly for a few women that have a high estimated cancer probability bigger than 0.4, the estimated probability does not change much with higher age. The next figures shows an ICE plot for the bike rental prediction (the underlying prediction model is a RandomForest). FIGURE 5.6: Individual conditional expectation plot of expected bike rentals and weather conditions. The same effects as in the partial dependence plots can be observed. All curves seem to follow the same course, so there seem to be no obvious interactions. That means that the PDP is already a good summary of the relationships of the displayed features and the predicted bike rentals. 5.2.1.1 Centered ICE Plot There is one issue with ICE plots: It can be hard to see if the individual conditional expectation curves differ between individuals, because they start at different \\(\\hat{f}(x)\\). An easy fix is to center the curves at a certain point in \\(x_S\\) and only display the difference in the predicted response. The resulting plot is called centered ICE plot (c-ICE). Anchoring the curves at the lower end of \\(x_S\\) is a good choice. The new curves are defined as: \\[\\hat{f}_{cent}^{(i)}=\\hat{f}_i-\\mathbf{1}\\hat{f}(x^{\\text{*}},x_{C_i})\\] where \\(\\mathbf{1}\\) is a vector of 1’s with the appropriate number of dimensions (usually one- or two-dimensional), \\(\\hat{f}\\) the fitted model and \\(x^{\\text{*}}\\) the anchor point. 5.2.1.2 Example Taking for example the cervical cancer ICE plot for age and centering the lines at the youngest observed age yields: FIGURE 5.7: Centered ICE plot for predicted cervical cancer risk probability by age. The lines are fixed to 0 at age 13 and each point shows the difference to the prediction with age 13. Compared to age 18, the predictions for most instances stay the same and see an increase up to 20 percent. A few cases show the opposite behavior: The predicted probability decreases with increasing age. With the centered ICE plots it is easier to compare the curves of individual instances. This can be useful when we are not interested in seeing the absolute change of a predicted value, but rather the difference in prediction compared to a fixed point of the feature range. The same for the bike dataset and count prediction model: FIGURE 5.8: Centred individual conditional expectation plots of expected bike rentals by weather condition. The lines were fixed at value 0 for each feature and instance. The lines show the difference in prediction compared to the prediction with the respective feature value at their minimal feature value in the data. 5.2.1.3 Derivative ICE Plot Another way to make it visually easier to spot heterogeneity is to look at the individual derivatives of \\(\\hat{f}\\) with respect to \\(x_S\\) instead of the predicted response \\(\\hat{f}\\). The resulting plot is called derivative ICE plot (d-ICE). The derivatives of a function (or curve) tell you in which direction changes occur and if any occur at all. With the derivative ICE plot it is easy to spot value ranges in a feature where the black box’s predicted values change for (at least some) instances. If there is no interaction between \\(x_S\\) and \\(x_C\\), then \\(\\hat{f}\\) can be expressed as: \\[\\hat{f}(x)=\\hat{f}(x_S,x_C)=g(x_S)+h(x_C),\\quad\\text{with}\\quad\\frac{\\delta\\hat{f}(x)}{\\delta{}x_S}\\] Without interactions, the individual partial derivatives should be the same for all instances. If they differ, it is because of interactions and it will become visible in the d-ICE plot. In addition to displaying the individual curves for derivative \\(\\hat{f}\\), showing the standard deviation of derivative \\(\\hat{f}\\) helps to highlight regions in \\(x_S\\) with heterogeneity in the estimated derivatives. The derivative ICE plot takes a long time to compute and is rather impractical. 5.2.2 Advantages Individual conditional expectation curves are even more intuitive to understand than partial dependence plots: One line represents the predictions for one instance when we vary the feature of interest. In contrast to partial dependence plots they can uncover heterogeneous relationships. 5.2.3 Disadvantages ICE curves can only display one feature meaningfully, because two features would require drawing multiple, overlaying surfaces and there is no way you would still see anything in the plot. ICE curves suffer from the same problem as PDPs: When the feature of interest is correlated with the other features, then not all points in the lines might be valid data points according to the joint feature distribution. When many ICE curves are drawn the plot can become overcrowded and you don’t see anything any more. The solution: either add some transparency to the lines or only draw a sample of the lines. In ICE plots it might not be easy to see the average. This has a simple solution: just combine individual conditional expectation curves with the partial dependence plot. "],
["interaction.html", "5.3 Feature Interaction", " 5.3 Feature Interaction When features in a prediction model interact with each other, then the influence of the features on the prediction is not additive but more complex. It follows that Aristotle’s predicate “the whole is greater than the sum of its parts.” only applies in the presence of feature interactions. 5.3.1 Feature Interaction? When a machine learning model makes a prediction based on two features, we can decompose the prediction into four terms: a constant term, one term for the first feature, one for the second feature and one for the interaction effect between the two features. The interaction between two features is the change in the prediction that occurs by varying the features, after having accounted for the individual feature effects. It’s the effect that comes on top of the sum of the individual feature effects. For example: a model predicts the value of a house, using house size (big or small) and location (good or bad) as features, amounting to four possible predictions: Location Size Predicted value good big 300,000 good small 200,000 bad big 250,000 bad small 150,000 We decompose the model prediction into the following parts: A constant term (150,000), an effect for the size feature (+100,000 if big, +0 if small) and an effect for the location (+50,000 if good, +0 if bad). This decomposition fully explains the model predictions. There is no interaction effect, because the model prediction is a sum of the single feature effects for size and location. Making a small house big always adds 100,000 to the predicted value, no matter the location. Also the difference in predicted value between a good and a bad location is 50,000, independent of the size. Now let’s consider an example with interaction: Location Size Predicted value good big 400,000 good small 200,000 bad big 250,000 bad small 150,000 We decompose the prediction table into the following parts: A constant term (150,000), an effect for the size feature (+100,000 if big, +0 if small) and an effect for the location (+50,000 if good, +0 if bad). For this table, we need an extra term for the interaction: +100,000 if the house is big and in a good location. This is an interaction between the size and the location, because in this case, the difference in predicted value between a big and a small house depends on the location. One way to estimate the interaction strength is to measure how much of the variation of the predicted outcome depends on the interaction of the features. This measurement is called H-statistic, introduced by Friedman and Popescu (2008)26 5.3.2 Theory: Friedman’s H-statistic We will look into two cases: The interaction between two features, which tells us if and how strongly two specific features interact with each other in the model; The interaction between a feature and all other features, which tells us if and how strongly (in total) the specific feature interacts in the model with all the other features. In theory, arbitrary interactions between any number of features can be measured, but those two cases represent the most interesting interaction cases. If two features \\(x_j\\) and \\(x_k\\) don’t interact, we can decompose the partial dependence function in the following way (assuming that the partial dependence functions are centered at zero): \\[PD_{jk}(x_j,x_k)=PD_j(x_j)+PD_k(x_k)\\] where \\(PD_{jk}(x_j,x_k)\\) is the 2-way partial dependence function of both features and \\(PD_j(x_j)\\) and \\(PD_k(x_k)\\) the partial dependence functions of the single features. Similarly, if a feature \\(x_j\\) has no interaction with any of the other features, we can express the prediction function \\(\\hat{f}(x)\\) as a sum of partial dependence functions, where the first summand only depends on \\(x_j\\) and the second depends on all other features excluding \\(x_j\\): \\[\\hat{f}(x)=PD_j(x_j)+PD_{-j}(x_{-j})\\] where \\(PD_{-j}(x_{-j})\\) is the partial dependence function that depends on all features excluding \\(x_j\\). This decomposition expresses the partial dependence (or full prediction) function without interactions (between features \\(x_j\\) and \\(x_k\\) or, respectively, \\(x_j\\) and \\(x_{-j}\\)). In a next step we measure the difference between the observed partial dependence function and the decomposed one without interactions. We calculate the variance of the output of the partial dependence (for measuring the interaction between two features) or of the complete function (for measuring the interaction between a feature and all other features). The amount of the variance that is explained by the interaction (difference between observed and no-interaction PD) is used as the interaction strength statistic. The statistic is 0 when there is no interaction at all and 1 if all of the variance of the \\(PD_{jk}\\) or \\(\\hat{f}\\) is explained by the sum of the partial dependence functions. An interaction statistic of 1 between two features means that each single \\(PD\\) function is constant and the effect on the prediction only comes through the interaction. In mathematical terms, the H-statistic for the interaction between feature \\(x_j\\) and \\(x_k\\) proposed by Friedman and Popescu is: \\[H^2_{jk}=\\sum_{i=1}^n\\left[PD_{jk}(x_{j}^{(i)},x_k^{(i)})-PD_j(x_j^{(i)})-PD_k(x_{k}^{(i)})\\right]/\\sum_{i=1}^n{PD}^2_{jk}(x_j^{(i)},x_k^{(i)})\\] Similarly for measuring if a feature \\(x_j\\) interacts with any other feature: \\[H^2_{j}=\\sum_{i=1}^n\\left[\\hat{f}(x^{(i)})-PD_j(x_j^{(i)})-PD_{-j}(x_{-j}^{(i)})\\right]/\\sum_{i=1}^n\\hat{f}^2(x^{(i)})\\] The H-statistic is expensive to evaluate, because it iterates over all data points and at each point the partial dependence has to be evaluated which is done using - again - all \\(n\\) data points. In the worst case, we need \\(2n^2\\) calls to the machine learning models predict function to compute the \\(H^2_j\\)-statistic and \\(3n^2\\) for the \\(H^2_{jk}\\)-statistic. To speed up the computation, we can sample from the \\(n\\) data points . This has the drawback that it adds variance to the partial dependence estimates, which makes the statistic unstable. So when you are using sampling to reduce the computational burden, make sure to sample enough data points. In their paper, Friedman and Popescu also propose a test for the H-statistic being significantly different from zero: The Null hypothesis is the absence of interaction. To generate the interaction statistic under the Null hypothesis, you have to be able to adjust the model so that it has no interaction between feature \\(x_j\\) and \\(x_k\\) or all others. This is not possible for all types of models, so running this test is model-specific and not model-agnostic and as such not covered here. The interaction strength statistic can also be applied in a classification setting, when the predicted outcome is the probability for a class. 5.3.3 Examples Let’s see how feature interactions look like in practice! We measure the interaction strength of features in a support vector machine that predicts the number of bike rentals, given weather and calendrical features. The following plot shows the results of the feature interaction analysis: FIGURE 5.9: The interaction strength for each feature with all other features for a support vector machine predicting bike rentals. Overall the interaction effects between the features are very weak (below 1 percent of variance explained by each feature). In this next example we calculate the interaction statistic for a classification problem, where we deal with the partial dependence of the predicted probability. We analyse the interactions between features in a random forest that is trained to predict cervical cancer, given some risk factors. FIGURE 5.10: The interaction strength for each feature with all other features for a random forest predicting the probability of cervical cancer. The number of diagnosed sexually transmitted diseases has the highest interaction effect with all other features, followed by the number of pregnancies. After looking into the feature interactions of each feature with all other features, we can pick one of the features and specifically dive deeper into all the 2-way interactions between the chosen feature with the other features: FIGURE 5.11: The 2-way interactions between number of pregnancies with each other feature. There is a strong interaction between the number of pregnancies and the age. 5.3.4 Advantages The interaction statistic has an underlying theory through the partial dependence decomposition. The H-statistic has a meaningful interpretation: The interaction is defined as the portion of variance explained by the interaction. Since the statistic is dimensionless and always between 0 and 1, it is comparable across features and even across models. The statistic detects all kinds of interactions, regardless of a specific form. With the H-statistic it is also possible to analyze arbitrary higher interactions: For example the interaction strength between 3 or more features. 5.3.5 Disadvantages The first thing you will notice: The interaction H-statistic takes a long time to compute, because it’s computationally expensive. Sometimes the results are weird and for small simulations don’t yield the expected results. But this is more anecdotal evidence. The computation involves estimating marginal distributions. These estimates also have some variance, when we don’t use all of the data points. This means when we sample points, the estimates will also vary from run to run and the results might become unstable. I recommend repeating it a few times to see if you have enough data included for a stable result. It is unclear whether an interaction is significantly bigger than 0. We would need to conduct a statistical test, but this test is not (yet) available in a model-agnostic version. Connected to the testing problem: It’s hard to tell when the H-statistic is large enough that we would consider it a strong interaction. The H-statistic tells us how strong the interactions are, but it doesn’t tell us how the interaction is shaped. That’s what partial dependence plots are for. A meaningful workflow is to measure the interaction strengths and then create 2D-partial dependence plots for the interactions in which you are interested. The H-statistic can’t be meaningfully applied if the inputs are pixels. The interaction statistic works under the assumption that we can independently shuffle features (the same problem that partial dependence plots have). When the features strongly correlate, the assumption is violated and we integrate over feature combinations that are very unlikely in reality. 5.3.6 Implementations For the examples in this book, I used the R package iml, which is available on CRAN and the development version on Github. There are other implementations, which focus on a specific model: The R package pre implements the RuleFit algorithm plus the H-statistic. The R package gbm implements gradient boosted models plus the H-statistic. 5.3.7 Alternatives The H-statistic is not the only way to measure interactions, there is also: Variable Interaction Networks (VIN) by Hooker (2004)27: An approach that decomposes the prediction function into main effects and feature interactions. The interactions between features are then visualized as a network. Unfortunately, there is no software available yet. Partial dependence based feature interaction by Greenwell et. al (2018)28: For measuring the interaction between two features, this approach measures the feature importance (defined as the variance of the 1D partial dependence function) of one feature conditional on different, fixed points of the other feature. When the variance is high, then the features interact with each other, if it is zero, they don’t interact. The R package vip is available on Github. They also cover partial dependence plots and feature importance. Friedman, Jerome H, and Bogdan E Popescu. 2008. “Predictive Learning via Rule Ensembles.” The Annals of Applied Statistics. JSTOR, 916–54.↩ Hooker, G. (2004). Discovering Additive Structure in Black Box Functions. Knowledge Discovery and Data Mining, 575–580. http://doi.org/10.1145/1014052.1014122↩ Greenwell, B. M., Boehmke, B. C., &amp; McCarthy, A. J. (2018). A Simple and Effective Model-Based Variable Importance Measure, 1–27. Retrieved from http://arxiv.org/abs/1805.04755↩ "],
["feature-importance.html", "5.4 Feature Importance", " 5.4 Feature Importance A feature’s importance is the increase in the model’s prediction error after we permuted the feature’s values (breaks the relationship between the feature and the outcome). 5.4.1 The Theory The concept is really straightforward: We measure a feature’s importance by calculating the increase of the model’s prediction error after permuting the feature. A feature is “important”, if permuting its values increases the model error, because the model relied on the feature for the prediction; A feature is “unimportant” if permuting its values keeps the model error unchanged, because the model ignored the feature for the prediction. The permutation feature importance measurement was introduced for Random Forests by Breiman (2001)[^Breiman2011]. Based on this idea, Fisher, Rudin, and Dominici (2018)29 proposed a model-agnostic version of the feature importance - they called it model reliance. They also introduce more advanced ideas about feature importance, for example a (model-specific) version that accounts for the fact that many prediction models may fit the data well. Their paper is worth a read. The algorithm: Input: Trained model \\(\\hat{f}\\), feature matrix \\(X\\), target vector \\(Y\\), error measure \\(L(Y,\\hat{Y})\\) Estimate the original model error \\(e_{orig}(\\hat{f})=L(Y,\\hat{f}(X))\\) (e.g. mean squared error) For each feature \\(j\\in1,\\ldots,p\\) do Generate feature matrix \\(X_{perm_{j}}\\) by permuting feature \\(X_j\\) in \\(X\\). This breaks the association between \\(X_j\\) and \\(Y\\). Estimate error \\(e_{perm}=L(Y,\\hat{f}(X_{perm_j}))\\) based on the predictions of the permuted data. Calculate permutation feature importance \\(FI_j=e_{perm}(\\hat{f})/e_{orig}(\\hat{f})\\). Alternatively, the difference can be used: \\(FI_j=e_{perm}(\\hat{f})-e_{orig}(\\hat{f})\\) Sort variables by descending \\(FI\\). In their paper, Fisher, Rudin, and Dominici (2018) propose to split the dataset in half and exchange the \\(X_j\\) values of the two halves instead of permuting \\(X_j\\). This is exactly the same as permuting the feature \\(X_j\\) if you think about it. If you want to have a more accurate estimate, you can estimate the error of permuting \\(X_j\\) by pairing each instance with the \\(X_j\\) value of each other instance (except with itself). This gives you a dataset of size \\(n(n-1)\\) to estimate the permutation error and it takes a big amount of computation time. I can only recommend using the \\(n(n-1)\\) - method when you are serious about getting extremely accurate estimates. 5.4.2 Example and Interpretation We show examples for classification and regression. Cervical cancer (Classification) We fit a random forest model to predict cervical cancer. We measure the error increase by: \\(1-AUC\\) (one minus the area under the ROC curve). Features that are associated model error increase by a factor of 1 (= no change) were not important for predicting cervical cancer. FIGURE 5.12: The importance for each of the features in predicting cervical cancer with a random forest. The importance is the factor by which the error is increased compared to the original model error. The feature with the highest importance was associated with an error increase of 7.01 after permutation. Bike rentals (Regression) We fit a support vector machine model to predict bike rentals, given weather conditions and calendric information. As error measurement we use the mean absolute error. FIGURE 5.13: The importance for each of the features in predicting bike rentals with a support vector machine. 5.4.3 Advantages Nice interpretation: Feature importance is the increase of model error when the feature’s information is destroyed. Feature importance provides a highly compressed, global insight into the model’s behavior. A positive aspect of using the error ratio instead of the error difference is that the feature importance measurements are comparable across different problems. 5.4.4 Disadvantages The feature importance measure is tied to the error of the model. This is not inherently bad, but in some cases not what you need. In some cases you would prefer to know how much the model’s output varies for one feature, ignoring what it means for the performance. For example: You want to find out how robust your model’s output is, given someone manipulates the features. In this case, you wouldn’t be interested in how much the model performance drops given the permutation of a feature, but rather how much of the model’s output variance is explained by each feature. Model variance (explained by the features) and feature importance correlate strongly, when the model generalizes well (i.e. it doesn’t overfit). You need access to the actual outcome target. If someone only gives you the model and unlabeled data - but not the actual target- you can’t compute the permutation feature importance. Fisher, Aaron, Cynthia Rudin, and Francesca Dominici. 2018. “Model Class Reliance: Variable Importance Measures for any Machine Learning Model Class, from the ‘Rashomon’ Perspective.” http://arxiv.org/abs/1801.01489.↩ "],
["global.html", "5.5 Global Surrogate Models", " 5.5 Global Surrogate Models A global surrogate model is an interpretable model that is trained to approximate the predictions of a black box model. We can draw conclusions about the black box model by interpreting the surrogate model. Solving machine learning interpretability by using more machine learning! 5.5.1 Theory Surrogate models are also used in engineering: When an outcome of interest is expensive, time-consuming or otherwise difficult to measure (for example because it comes from a complex computational simulation), a cheap and fast surrogate model of the outcome is used instead. The difference between the surrogate models used in engineering and for interpretable machine learning is that the underlying model is a machine learning model (not a simulation) and that the surrogate model has to be interpretable. The purpose of (interpretable) surrogate models is to approximate the predictions of the underlying model as closely as possible while being interpretable. You will find the idea of surrogate models under a variety of names: Approximation model, metamodel, response surface model, emulator, … So, about the theory: there is actually not much theory needed to understand surrogate models. We want to approximate our black box prediction function \\(\\hat{f}(x)\\) as closely as possible with the surrogate model prediction function \\(\\hat{g}(x)\\), under the constraint that \\(g\\) is interpretable. Any interpretable model - for example from the interpretable models chapter - can be used for the function \\(g\\): For example a linear model: \\[\\hat{g}(x)=\\beta_0+\\beta_1{}x_1{}+\\ldots+\\beta_p{}x_p\\] Or a decision tree: \\[\\hat{g}(x)=\\sum_{m=1}^Mc_m{}I\\{x\\in{}R_m\\}\\] Fitting a surrogate model is a model-agnostic method, since it requires no information about the inner workings of the black box model, only the relation of input and predicted output is used. If the underlying machine learning model would be exchanged for another, you could still apply the surrogate method. The choice of the black box model type and of the surrogate model type is decoupled. Perform the following steps to get a surrogate model: Choose a dataset \\(X\\). This could be the same dataset that was used for training the black box model or a new dataset from the same distribution. You could even choose a subset of the data or a grid of points, depending on your application. For the chosen dataset \\(X\\), get the predictions \\(\\hat{y}\\) of the black box model. Choose an interpretable model (linear model, decision tree, …). Train the interpretable model on the dataset \\(X\\) and its predictions \\(\\hat{y}\\). Congratulations! You now have a surrogate model. Measure how well the surrogate model replicates the prediction of the black box model. Interpret / visualize the surrogate model. You might find approaches for surrogate models which have some extra steps or differ a bit, but the general idea is usually the same as described here. A way to measure how well the surrogate replicates the black box model is the R squared measure: \\[R^2=1-\\frac{SSE}{SST}=1-\\frac{\\sum_{i=1}^n(\\hat{y}^*_i-\\hat{y}_i)^2}{\\sum_{i=1}^n(\\hat{y}_i-\\bar{\\hat{y}})^2}\\] where \\(\\hat{y}^*_i\\) is the prediction for the i-th instance of the surrogate model and respectively \\(\\hat{y}_i\\) of the black box model. The mean of the black box model predictions is \\(\\bar{\\hat{y}}\\). \\(SSE\\) stands for sum of squares error and \\(SST\\) for sum of squares total. The R squared measure can be interpreted as the percentage of variance that is captured by the interpretable model. If the R squared is close to 1 (= low \\(SSE\\)), then the interpretable model approximates the behaviour of the black box model very well. If the interpretable model is that close, you might want to replace the complex model with the interpretable model. If the R squared is close to 0 (= high \\(SSE\\)), then the interpretable model fails to explain the black box model. Note that we haven’t talked about the model performance of the underlying black box model, meaning how well or badly it performs at predicting the real outcome. For fitting the surrogate model, the performance of the black box model does not matter at all. The interpretation of the surrogate model is still valid, because it makes statements about the model and not about the real world. But of course, the interpretation of the surrogate model becomes irrelevant if the black box model sucks, because then the black box model itself is irrelevant. We could also build a surrogate model based on a subset of the original data or re-weight the instances. In this way, we change the distribution of the surrogate model’s input, which changes the focus of the interpretation (then it is not really global any longer). When we weight the data locally around a certain instance of the data (the closer the instances to the chosen instance, the higher their weight) we get a local surrogate model, which can be used to explain the instance’s individual prediction. Learn more about local models in the following chapter. 5.5.2 Example To demonstrate the surrogate models, we look at a regression and a classification example. First, we fit a support vector machine to predict the daily number of bike rentals given weather and calendrical information. The support vector machine is not very interpretable, so we fit a surrogate with a CART decision tree as interpretable model to approximate the behaviour of the support vector machine. FIGURE 5.14: The terminal nodes of a surrogate tree that approximates the behaviour of a support vector machine trained on the bike rental dataset. The distributions in the nodes show that the surrogate tree predicts a higher number of bike rentals when the weather is above around 13 degrees (Celsius) and when the day was later in the 2 year period (cut point at 435 days). The surrogate model has an R squared (variance explained) of 0.77 which means it approximates the underlying black box behaviour quite well, but not perfectly. If the fit would be perfect, we could actually throw away the support vector machine and use the tree instead. In our second example, we predict the probability for cervical cancer with a random forest. Again we fit a decision tree, using the original dataset, but with the prediction of the random forest as outcome, instead of the real classes (healthy vs. cancer) from the data. FIGURE 5.15: The terminal nodes of a surrogate tree that approximates the behaviour of a random forest trained on the cervical cancer dataset. The counts in the nodes show the distribution of the black box models classifications in the nodes. The surrogate model has an R squared (variance explained) of 0.2 which means it doesn’t approximate the random forest well and we should not over-interpret the tree, when drawing conclusions about the complex model. 5.5.3 Advantages The surrogate model method is flexible: Any model from the interpretable models chapter can be used. This also means that you can swap not only the interpretable model, but also the underlying black box model. Let’s say you build some complex model and you want to explain it to different teams in your company. One team is familiar with linear models; the other team prefers decision trees. You can fit two surrogate models (linear model and decision tree) for the original black box model and offer two kinds of explanations. If you find a better performing black box model, you don’t have to change the way you do interpretation, because you can use the same class of surrogate models. I’d argue that the approach is very intuitive and straightforward. This means it is easy to implement, but also easy to explain to people not familiar with data science or machine learning. With the R squard measure, we can easily measure how good our surrogate models are in terms of approximation of the black box predictions. 5.5.4 Disadvantages Be careful to draw conclusions about the model, not the data, since the surrogate model never sees the real outcome. It’s not clear what the best cut-off for R squared is in order to be confident that the surrogate model is close enough to the black box model. 80% of variance explained? 50%? 99%? We can measure how close the surrogate model is to the black box model. Let’s assume we are not very close, but close enough. It could happen that the interpretable model is very close for a subset of the dataset, but wildly diverges for another subset. In this case the interpretation for the simple model would not be equally good for all data points. The interpretable model you choose as a surrogate comes with all its advantages and disadvantages. Some people argue that there are - in general - no intrinsically interpretable models (including even linear models and decision trees) and that it would even be dangerous to have an illusion of interpretability. If you share this opinion, then this method is, of course, not for you. "],
["lime.html", "5.6 Local Surrogate Models (LIME)", " 5.6 Local Surrogate Models (LIME) Local interpretable model-agnostic explanations (LIME) (Ribeiro, M.T., Singh, S. and Guestrin, C., 201630) is a method for fitting local, interpretable models that can explain single predictions of any black-box machine learning model. LIME explanations are local surrogate models. Surrogate models are interpretable models (like a linear model or decision tree) that are learned on the predictions of the original black box model. But instead of trying to fit a global surrogate model, LIME focuses on fitting local surrogate models to explain why single predictions were made. The idea is quite intuitive. First of all, forget about the training data and imagine you only have the black box model where you can input data points and get the models predicted outcome. You can probe the box as often as you want. Your goal is to understand why the machine learning model gave the outcome it produced. LIME tests out what happens to the model’s predictions when you feed variations of your data into the machine learning model. LIME generates a new dataset consisting of perturbed samples and the associated black box model’s predictions. On this dataset LIME then trains an interpretable model weighted by the proximity of the sampled instances to the instance of interest. The interpretable model can basically be anything from this chapter, for example LASSO or a decision tree. The learned model should be a good approximation of the machine learning model locally, but it does not have to be so globally. This kind of accuracy is also called local fidelity. The recipe for fitting local surrogate models: Choose your instance of interest for which you want to have an explanation of its black box prediction. Perturb your dataset and get the black box predictions for these new points. Weight the new samples by their proximity to the instance of interest. Fit a weighted, interpretable model on the dataset with the variations. Explain prediction by interpreting the local model. In the current implementations (R and Python) for example linear regression can be chosen as interpretable surrogate model. Upfront you have to choose \\(K\\), the number of features that you want to have in your interpretable model. The lower the \\(K\\), the easier the model is to interpret, higher \\(K\\) potentially creates models with higher fidelity. There are different methods for how to fit models with exactly \\(K\\) features. A solid choice is Lasso. A Lasso model with a high regularisation parameter \\(\\lambda\\) yields a model with only the intercept. By refitting the Lasso models with slowly decreasing \\(\\lambda\\), one after each other, the features are getting weight estimates different from zero. When \\(K\\) features are in the model, you reached the desired number of features. Other strategies are forward or backward selection of features. This means you either start with the full model (=containing all features) or with a model with only the intercept and then testing which feature would create the biggest improvement when added or removed, until a model with \\(K\\) features is reached. Other interpretable models like decision trees are also possible. As always, the devil’s in the details. In a high-dimensional space, defining a neighbourhood is not trivial. Distance measures are quite arbitrary and distances in different dimensions (aka features) might not be comparable at all. How big should the neighbourhood be? If it is too small, then there might be no difference in the predictions of the machine learning model at all. LIME currently has a hard coded kernel and kernel width, which define the neighbourhood, and there is no answer how to figure out the best kernel or how to find the optimal width. The other question is: How do you get the variations of the data? This differs depending on the type of data, which can be either text, an image or tabular data. For text and image the solution is turning off and on single words or super-pixels. In the case of tabular data, LIME creates new samples by perturbing each feature individually, by drawing from a normal distribution with mean and standard deviation from the feature. LIME does a good job in creating selective explanations, which humans prefer. That’s why I see LIME more in applications where the recipient of the explanation is a lay-person or someone with very little time. It is not sufficient for complete causal attributions, so I don’t see LIME in compliance scenarios, where you are legally required to fully explain a prediction. Also for debugging machine learning models it is useful to have all the reasons instead of a few. 5.6.1 LIME for Tabular Data Tabular data means any data that comes in tables, where each row represents an instance and each column a feature. LIME sampling is not done around the instance of interest, but from the training data’s mass centre, which is problematic. But it increases the likelihood that the outcome for some of the sampled points predictions differ from the data point of interest and that LIME can learn at least some explanation. It’s best to visually explain how the sampling and local model fitting works: FIGURE 5.16: How LIME sampling works: A) The black box model predicts one of two classes given feature x1 and x2. Most data points have class 0 (darker colour), and the ones with class 1 are grouped in an upside-down V-shape (lighter colour). The plot displays the decision boundaries learned by a machine learning model. In this case it was a Random Forest, but it does not matter, because LIME is model-agnostic and we only care about the decision boundaries. B) The yellow point is the instance of interest, which we want to explain. The black dots are data sampled from a normal distribution around the means of the features in the training sample. This needs to be done only once and can be reused for other explanations. C) Introducing locality by giving points near the instance of interest higher weights. D) The colours and signs of the grid display the classifications of the locally learned model form the weighted samples. The white line marks the decision boundary (P(class) = 0.5) at which the classification of the local model changes. 5.6.1.1 Example Let’s look at a concrete example. We go back to the bike rental data and turn the prediction problem into a classification: After accounting for the trend that the bike rental get’s more popular over time we want to know on a given day if the number of rented bikes will be above or below the trend line. You can also interpret ‘above’ as being above the mean bike counts, but adjusted for the trend. First we train a Random Forest with 100 trees on the classification task. Given seasonal and weather information, on which day will the number of bike rentals be above the trend-free average? The explanations are created with 2 features. The results of the sparse local linear model that was fitted for two instances with different predicted classes: FIGURE 5.17: LIME explanations for two instances of the bike rental dataset. Warmer temperature and good weather situation have a positive effect on the prediction. The x-axis shows the feature effect: The weight times the actual feature value. It becomes clear from the figure, that it is easier to interpret categorical features than numerical features. A solution is to categorize the numerical features into bins. 5.6.2 LIME for Text LIME for text differs from LIME for tabular data. Variations of the data are created differently: Starting from the original text, new texts are created by randomly removing words from it. The dataset is represented with binary features for each word. A feature is 1 if the respective word is included and 0 if it was removed. 5.6.2.1 Example In this example we classify spam vs. ham of YouTube comments. The black box model is a decision tree on the document word matrix. Each comment is one document (= one row) and each column is the number of occurrences of a specific word. Decision trees are easy to understand, but in this case the tree is very deep. Also in the place of this tree there could have been a recurrent neural network or a support vector machine that was trained on the embeddings from word2vec. From the remaining comments two were selected for showing the explanations. Let’s look at two comments of this dataset and the corresponding classes: CONTENT CLASS 267 PSY is a good guy 0 173 For Christmas Song visit my channel! ;) 1 In the next step we create some variations of the datasets, which are used in a local model. For example some variations of one of the comments: For Christmas Song visit my channel! ;) prob weight 2 1 0 1 1 0 0 1 0.09 0.57 3 0 1 1 1 1 0 1 0.09 0.71 4 1 0 0 1 1 1 1 0.99 0.71 5 1 0 1 1 1 1 1 0.99 0.86 6 0 1 1 1 0 0 1 0.09 0.57 Each column corresponds to one word in the sentence. Each row is a variation, 1 indicates that the word is part of this variation and 0 indicates that the word has been removed. The corresponding sentence for the first variation is “Christmas Song visit my ;)”. And here are the two sentences (one spam, one no spam) with their estimated local weights found by the LIME algorithm: case label_prob feature feature_weight 1 0.0872151 good 0.000000 1 0.0872151 a 0.000000 1 0.0872151 PSY 0.000000 2 0.9939759 channel! 6.908755 2 0.9939759 visit 0.000000 2 0.9939759 Christmas 0.000000 The wor d “channel” p oints to a h igh probability of spam. 5.6.3 LIME for Images This section was written by Verena Haunschmid. LIME for images works differently than for tabular data and text. Intuitively it would not make much sense to perturb single pixels, since a lot more than one pixel contribute to one class. By randomly changing individual pixels, the predictions would probably not change much. Therefore, variations of the samples (i.e. images) are created by performing superpixel segmentation and switching superpixels off. Superpixels are connected pixels with similar colors and can be turned off by replacing each pixel by a user provided color (e.g., a reasonable value would by gray). The user can also provide a probability for turning off a superpixel in each permutation. 5.6.3.1 Example Since the computation of image explanations is rather slow, the lime R package contains a precomputed example which we will also use to show the output of the method. Image data is great for visualization, the explanations can be displayed directly on the image samples. Since we can have several predicted labels per image (ordered by probability), we can explain the top n_labels. For the following image the top 3 predictions were strawberry; candle, taper, wax light; and Granny Smith. The prediction and the explanation in the first case are very reasonable. For the second prediction it is quite interesting to see which part of the image contributed to this class. We could conclude that there were objects labeled as candle, taper, wax light in the training set that looked shiny like the tomato. FIGURE 5.18: LIME expalanations for image classification. The example is taken from the lime R package. Ribeiro, M.T., Singh, S. and Guestrin, C., 2016, August. Why should i trust you?: Explaining the predictions of any classifier. In Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (pp. 1135-1144). ACM.↩ "],
["shapley.html", "5.7 Shapley Value Explanations", " 5.7 Shapley Value Explanations Predictions can be explained by assuming that each feature is a ‘player’ in a game where the prediction is the payout. The Shapley value - a method from coalitional game theory - tells us how to fairly distribute the ‘payout’ among the features. 5.7.1 The general idea Assume the following scenario: You trained a machine learning model to predict apartment prices. For a certain apartment it predicts 300,000 € and you need to explain this prediction. The apartment has a size of 50 m2, is located on the 2nd floor, with a park nearby and cats are forbidden: FIGURE 5.19: The predicted price for our apartment is 300,000€. It’s a 50 square meter apartment on the second floor. There is a park nearby and cats are forbidden. Our goal is to explain how each of these features values contributed towards the predicted price of 300k€. The average prediction for all apartments is 310,000€. How much did each feature value contribute to the prediction compared to the average prediction? The answer is easy for linear regression models: The effect of each feature is the weight of the feature times the feature value minus the average effect of all apartments: This works only because of the linearity of the model. For more complex model we need a different solution. For example LIME suggests local models to estimate effects. A different solution comes from cooperative game theory: The Shapley value, coined by Shapley (1953)31, is a method for assigning payouts to players depending on their contribution towards the total payout. Players cooperate in a coalition and obtain a certain gain from that cooperation. Players? Game? Payout? What’s the connection to machine learning prediction and interpretability? The ‘game’ is the prediction task for a single instance of the dataset. The ‘gain’ is the actual prediction for this instance minus the average prediction of all instances. The ‘players’ are the feature values of the instance, which collaborate to receive the gain (= predict a certain value). In our apartment example, the feature values ‘park-allowed’, ‘cat-forbidden’, ‘area-50m2’ and ‘floor-2nd’ worked together to achieve the prediction of 300,000€. Our goal is to explain the difference of the actual prediction (300,000€) and the average prediction (310,000€): a difference of -10,000€. The answer might be: The ‘park-nearby’ contributed 30,000€; ‘size-50m2’ contributed 10,000€; ‘floor-2nd’ contributed 0€; ‘cat-forbidden’ contributed -50,000€. The contributions add up to -10,000€: the final prediction minus the average predicted apartment price. How do we calculate the Shapley value for one feature? The Shapley value is the average marginal contribution of a feature value over all possible coalitions. All clear now? How to compute the contribution of a feature value to a coalition: FIGURE 5.20: We assess the contribution of the ‘cat-forbidden’ feature value when added to a coalition of ‘park-nearby’, ‘size-50m2’. We simulate that only ‘park-nearby’, ‘cat-forbidden’ and ‘size-50m2’ are in a coalition by randomly drawing the value for the floor feature. Then we predict the price of the apartment with this combination (301,000€). In a second step we remove ‘cat-forbidden’ from the coalition by replacing it with a random value of the cat allowed/forbidden feature from the randomly drawn apartment. In the example it was ‘cat-allowed’, but it could have been ‘cat-forbidden’ again. We predict the apartment price for the coalition of ‘park-nearby’ and ‘size-50m2’ (320,000€). The contribution of ‘cat-forbidden’ was 301,000€ - 320,000€ = -19.000€. This estimation depends on the sampled non-participating feature values and we get better estimates by repeating this procedure. This figure shows the computation of the marginal contribution for only one coalition. The Shapley value is the weighted average of marginal contributions over all coalitions. We repeat this computation for all possible coalitions. The computation time increases exponentially with the number of features, so we have to sample from all possible coalitions. The Shapley value is the average over all the marginal contributions. Here are all coalitions for computing the Shapley value of the ‘cat-forbidden’ feature value: FIGURE 5.21: All coalitions of feature values that are needed to assess the Shapley value for ‘cat-forbidden’. The first row shows the coalition without any feature values. The 2nd, 3rd and 4th row show different coalitions - separated by ‘|’ - with increasing coalition size. For each of those coalitions we compute the predicted apartment price with and without the ‘cat-forbidden’ feature value and take the difference to get the marginal contribution. The Shapley value is the (weighted) average of marginal contributions. We replace the feature values of features that are not in a coalition with random feature values from the apartment dataset to get a prediction from the machine learning model. When we repeat the Shapley value for all feature values, we get the complete distribution of the prediction (minus the average) among the feature values. 5.7.2 Examples and Interpretation The interpretation of the Shapley value \\(\\phi_{ij}\\) for feature \\(j\\) and instance \\(i\\) is: the feature value \\(x_{ij}\\) contributed \\(\\phi_{ij}\\) towards the prediction for instance \\(i\\) compared to the average prediction for the dataset. The Shapley value works for both classification (if we deal with probabilities) and regression. We use the Shapley value to analyse the predictions of a Random Forest model predicting cervical cancer: FIGURE 5.22: Feature value contributions for woman 326 in the cervical cancer dataset. With a prediction of 0.43, this woman’s cancer probability is 0.41 above the average prediction of 0.03. The feature value that increased the probability the most is the number of diagnosed STDs. The feature contributions sum up to the difference of actual and average prediction (0.41). For the bike rental dataset we also train a Random Forest to predict the number of rented bikes for a day given the weather conditions and calendric information. The explanations created for the Random Forest prediction of one specific day: FIGURE 5.23: Feature value contributions for instance 285. With a predicted 2329 rented bikes, this day is -2189 below the average prediction of 4517. The feature values that had the most negative effects were the weather situation, humidity and the time trend (years since 2011). The temperature on that day had a positive effect compared to the average prediction. The feature contributions sum up to the difference of actual and average prediction (-2189). Be careful to interpret the Shapley value correctly: The Shapley value is the average contribution of a feature value towards the prediction in different coalitions. The Shapley value is NOT the difference in prediction when we would drop the feature from the model. 5.7.3 The Shapley Value in Detail This Section goes deeper into the definition and computation of the Shapley value for the curious reader. Skip this part straight to ‘Advantages and Disadvantages’ if you are not interested in the technicalities. We are interested in the effect each feature has on the prediction of a data point. In a linear model it is easy to calculate the individual effects. Here’s how a linear model prediction looks like for one data instance: \\[\\hat{f}(x_{i\\cdot})=\\hat{f}(x_{i1},\\ldots,x_{ip})=\\beta_0+\\beta_{1}x_{i1}+\\ldots+\\beta_{p}x_{ip}\\] where \\(x_{i\\cdot}\\) is the instance for which we want to compute the feature effects. Each \\(x_{ij}\\) is a feature value, with \\(j\\in\\{1,\\ldots,p\\}\\). The \\(\\beta_j\\) are the weights corresponding to \\(x_{ij}\\). The feature effect \\(\\phi_{ij}\\) of \\(x_{ij}\\) on the prediction \\(\\hat{f}(x_{i\\cdot})\\) is: \\[\\phi_{ij}(\\hat{f})=\\beta_{j}x_{ij}-E(\\beta_{j}X_{j})=\\beta_{j}x_{ij}-\\beta_{j}E(X_{j})\\] where \\(E(\\beta_jX_{j})\\) is the mean effect estimate for feature \\(X_{j}\\). The effect is the difference between the feature contribution to the equation minus the average contribution. Nice! Now we know how much each feature contributed towards the prediction. If we sum up all the feature effects over all features for one instance, the result is: \\[\\sum_{j=1}^{p}\\phi_{ij}(\\hat{f})=\\sum_{j=1}^p(\\beta_{j}x_{ij}-E(\\beta_{j}X_{j}))=(\\beta_0+\\sum_{j=1}^p\\beta_{j}x_{ij})-(\\beta_0+\\sum_{j=1}^{p}E(\\beta_{j}X_{j}))=\\hat{f}(x_{i\\cdot})-E(\\hat{f}(X))\\] This is the predicted value for the data point \\(x_{i\\cdot}\\) minus the average predicted value. Feature effects \\(\\phi_{ij}\\) can be negative. Now, can we do the same for any type of model? It would be great to have this as a model-agnostic tool. Since we don’t have the \\(\\beta\\)’s from a linear equation in other model types, we need a different solution. Help comes from unexpected places: cooperative game theory. The Shapley value is a solution for computing feature effects \\(\\phi_{ij}(\\hat{f})\\) for single predictions for any machine learning model \\(\\hat{f}\\). 5.7.3.1 The Shapley Value The Shapley value is defined via a value function \\(val\\) over players in S. The Shapley value of a feature value \\(x_{ij}\\) is it’s contribution to the payed outcome, weighted and summed over all possible feature value combinations: \\[\\phi_{ij}(val)=\\sum_{S\\subseteq\\{x_{i1},\\ldots,x_{ip}\\}\\setminus\\{x_{ij}\\}}\\frac{|S|!\\left(p-|S|-1\\right)!}{p!}\\left(val\\left(S\\cup\\{x_{ij}\\}\\right)-val(S)\\right)\\] where \\(S\\) is a subset of the features used in the model, \\(x_{i\\cdot}\\) is the vector feature values of instance \\(i\\) and \\(p\\) the number of features. \\(val_{x_i}(S)\\) is the prediction for feature values in set \\(S\\), marginalised over features not in \\(S\\): \\[val_{x_i}(S)=\\int\\hat{f}(x_{i1},\\ldots,x_{ip})d\\mathbb{P}_{X_{i\\cdot}\\notin{}S}-E_X(\\hat{f}(X))\\] You actually do multiple integrations, for each feature not in \\(S\\). One concrete example: The machine learning model works on 4 features \\(\\{x_{i1},x_{i2},x_{i3},x_{i4}\\}\\) and we evaluate \\(\\hat{f}\\) for the coalition \\(S\\) consisting of feature values \\(x_{i1}\\) and \\(x_{i3}\\): \\[val_{x_i}(S)=val_{x_i}(\\{x_{i1},x_{i3}\\})=\\int_{\\mathbb{R}}\\int_{\\mathbb{R}}\\hat{f}(x_{i1},X_{2},x_{i3},X_{4})d\\mathbb{P}_{X_2,X_4}-E_X(\\hat{f}(X))\\] This looks similar to the linear model feature effects! Don’t get confused by the many uses of the word ‘value’: The feature value is the numerical value of a feature and instance; the Shapley value is the feature contribution towards the prediction; the value function is the payout function given a certain coalition of players (feature values). The Shapley value is the only attribution method that satisfies the following properties (which can be seen as a definition of a fair payout): Efficiency: \\(\\sum\\nolimits_{j=1}^p\\phi_{ij}=\\hat{f}(x_i)-E_X(\\hat{f}(X))\\). The feature effects have to sum up to the difference of prediction for \\(x_{i\\cdot}\\) and the average. Symmetry: If \\(val(S\\cup\\{x_{ij}\\})=val(S\\cup\\{x_{ik}\\})\\) for all \\(S\\subseteq\\{x_{i1},\\ldots,x_{ip}\\}\\setminus\\{x_{ij},x_{ik}\\}\\), then \\(\\phi_{ij}=\\phi_{ik}\\). The contribution for two features should be the same if they contribute equally to all possible coalitions. Dummy: If \\(val(S\\cup\\{x_{ij}\\})=val(S)\\) for all \\(S\\subseteq\\{x_{i1},\\ldots,x_{ip}\\}\\), then \\(\\phi_{ij}=0\\). A feature which does not change the predicted value - no matter to which coalition of feature values it is added - should have a Shapley value of 0. Additivity: For a game with combined payouts \\(val+val^*\\) the respective Shapley values are \\(\\phi_{ij}+\\phi_{ij}^*\\). The additivity axiom has no practical relevance in the context of feature effects. An intuitive way to understand the Shapley value is the following illustration: The feature values enter a room in random order. All feature values in the room participate in the game (= contribute to the prediction). The Shapley value \\(\\phi_{ij}\\) is the average marginal contribution of feature value \\(x_{ij}\\) by joining whatever features already entered the room before, i.e. \\[\\phi_{ij}=\\sum_{\\text{All.orderings}}val(\\{\\text{features.before.j}\\}\\cup{}x_{ij})-val(\\{\\text{features.before.j}\\})\\] 5.7.3.2 Estimating the Shapley value All possible coalitions (sets) of features have to be evaluated, with and without the feature of interest for calculating the exact Shapley value for one feature value. For more than a few features, the exact solution to this problem becomes intractable, because the number of possible coalitions increases exponentially by adding more features. Strumbelj et al. (2014)32 suggest an approximation with Monte-Carlo sampling: \\[\\hat{\\phi}_{ij}=\\frac{1}{M}\\sum_{m=1}^M\\left(\\hat{f}(x^{*+j})-\\hat{f}(x^{*-j})\\right)\\] where \\(\\hat{f}(x^{*+j})\\) is the prediction for \\(x_{i\\cdot}\\), but with a random number of features values replaced by feature values from a random data point \\(x\\), excluding the feature value for \\(x_{ij}\\) The x-vector \\(x^{*-j}\\) is almost identical to \\(x^{*+j}\\), but the value \\(x_{ij}\\) is also taken from the sampled \\(x\\). Each of those \\(M\\) new instances are kind of ‘Frankensteins’, pieced together from two instances. Approximate Shapley Estimation Algorithm: Each feature value \\(x_{ij}\\)’s contribution towards the difference \\(\\hat{f}(x_{i\\cdot})-\\mathbb{E}(\\hat{f})\\) for instance \\(x_{i\\cdot}\\in{}X\\). Require: Number of iterations \\(M\\), instance of interest \\(x\\), data \\(X\\), and machine learning model \\(\\hat{f}\\) For all \\(j\\in\\{1,\\ldots,p\\}\\): For all \\(m\\in\\{1,\\ldots,M\\}\\): draw random instance \\(z\\) from \\(X\\) choose a random permutation of feature \\(o \\in \\pi(S)\\) order instance \\(x\\): \\(x_{o}=(x_{o_1},\\ldots,x_{o_j},\\ldots,x_{o_p})\\) order instance \\(z\\): \\(z_{o}=(z_{o_1},\\ldots,z_{o_j},\\ldots,z_{o_p})\\) construct two new instances \\(x^{*+j}=(x_{o_1},\\ldots,x_{o_{j-1}},x_{o_j},z_{o_{j+1}},\\ldots,z_{o_p})\\) \\(x^{*-j}=(x_{o_1},\\ldots,x_{o_{j-1}},z_{o_j},z_{o_{j+1}},\\ldots,z_{o_p})\\) \\(\\phi_{ij}^{(m)}=\\hat{f}(x^{*+j})-\\hat{f}(x^{*-j})\\) Compute the Shapley value as the average: \\(\\phi_{ij}(x)=\\frac{1}{M}\\sum_{m=1}^M\\phi_{ij}^{(m)}\\) First, select an instance of interest \\(i\\), a feature \\(j\\) and the number of samples \\(M\\). For each sample, a random instance from the data is chosen and the order of the features is mixed. From this instance, two new instances are created, by combining values from the instance of interest \\(x\\) and the sample. The first instance \\(x^{*+j}\\) is the instance of interest, but where all values in order before and including feature \\(j\\) are replaced by feature values from the sample. The second instance \\(x^{*-j}\\) is similar, but has all the values in order before, but excluding feature \\(j\\), replaced by features from the sample. The difference in prediction from the black box is computed: \\[\\phi_{ij}^{(m)}=\\hat{f}(x^{*+j})-\\hat{f}(x^{*-j})\\] All these differences are averaged and result in \\[\\phi_{ij}(x)=\\frac{1}{M}\\sum_{m=1}^M\\phi_{ij}^{(m)}\\] Averaging implicitly weighs samples by the probability distribution of \\(X\\). That’s not the only way to compute the Shapley value: For example, Lundberg and Lee (2016)33 propose a computation method that includes weight kernels and regularised linear regression. 5.7.4 Advantages The difference between the prediction and the average prediction is fairly distributed among the features values of the instance - the shapley efficiency property. This property sets the Shapley value apart from other methods like LIME. LIME does not guarantee to perfectly distribute the effects. It might make the Shapley value the only method to deliver a full explanation. In situations that demand explainability by law - like EU’s “right to explanations” - the Shapley value might actually be the only compliant method. I am not a lawyer, so this reflects only my intuition about the requirements. The Shapley value allows contrastive explanations: Instead of comparing a prediction with the average prediction of the whole dataset, you could compare it to a subset or even to a single datapoint. The Shapley value is the only explanation method with a solid theory. The axioms - efficiency, symmetry, dummy, additivity - give the explanation a reasonable foundation. Methods like LIME assume linear behaviour of the machine learning model locally but there is no theory why this should work or not. It’s mind-blowing to explain a prediction as a game played by the feature values. 5.7.5 Disadvantages The Shapley value needs a lot of computation time. In 99.9% of the real world problems the approximate solution - not the exact one - is feasible. An accurate computation of the Shapley value is potentially computational expensive, because there are \\(2^k\\) possible coalitions of features and the ‘absence’ of a feature has to be simulated by drawing random samples, which increases the variance for the estimate \\(\\phi_{ij}\\). The exponential number of the coalitions is handled by sampling coalitions and fixing the number of samples \\(M\\). Decreasing \\(M\\) reduces computation time, but increases the variance of \\(\\phi_{ij}\\). It is unclear how to choose a sensitive \\(M\\). The Shapley value can be misinterpreted: The Shapley value \\(\\phi_{ij}\\) of a feature \\(j\\) is not the difference in predicted value after the removal of feature \\(j\\). The interpretation of the Shapley value is rather: Given the current set of feature values, the total contribution of feature value \\(x_{ij}\\) to the difference in the actual prediction and the mean prediction is \\(\\phi_{ij}\\). The Shapley value is the wrong explanation method if you seek sparse explanations. Humans prefer selective explanations, like LIME produces, so especially for explanations facing lay-persons, LIME might be the better choice for feature effects computation. The Shapley value returns a simple value per feature, and not a prediction model like LIME. This means it can’t be used to make statements about changes in the prediction for changes in the input like: “If I would earn 300 € more per year, my credit score should go up by 5 points.” Shapley, Lloyd S. 1953. “A Value for N-Person Games.” Contributions to the Theory of Games 2 (28): 307–17.↩ Strumbelj, Erik, Igor Kononenko, Erik Štrumbelj, and Igor Kononenko. 2014. “Explaining prediction models and individual predictions with feature contributions.” Knowledge and Information Systems 41 (3): 647–65. doi:10.1007/s10115-013-0679-x.↩ Lundberg, Scott, and Su-In Lee. 2016. “An unexpected unity among methods for interpreting model predictions,” no. Nips: 1–6. http://arxiv.org/abs/1611.07478.↩ "],
["future.html", "Chapter 6 A Look into the Crystal Ball", " Chapter 6 A Look into the Crystal Ball What is the future of interpretable machine learning? This chapter is a speculative mental exercise and subjective guess how interpretable machine learning will develop. I opened the book with rather pessimistic short stories and would like to conclude with a more optimistic outlook. I have based my “predictions” on three premises: Digitization: Any (interesting) information will be digitized. Think of electronic cash and online transactions. Think of e-books, music and videos. Think of all the sensory data about our environment, human behavior, industrial production processes and so on. The drivers of the digitization of everything are: Cheap computers/sensors/memory, scaling effects (winner takes it all), new business models, modular value chains, cost pressure and much more. Automation: When a task can be automated and the cost of automation is lower than the cost of performing the task over time, the task will be automated. Even before the introduction of the computer, we had a certain degree of automation: For example, the weaving machine automated weaving or the steam machine automated horsepower. But computers and digitization are taking automation to the next level. Simply the fact that you can program for-loops, write Excel macros, automate e-mail responses, and so on, show how much an individual can automate. Ticket machines automate the purchase of train tickets (no cashier needed any longer), washing machines automate laundry, standing orders automate money transactions and so on. The automation of tasks frees up time and money, so there is a huge economic and personal incentive to automate things. We are currently observing the automation of language translation, driving and even scientific discovery. Misspecification: We are not (and never will be?) able to perfectly specify a goal with all its constraints. Think of the genie in a bottle, that always takes your wishes literally: “I want to be the richest person in the world!” -&gt; You become the richest person, but as a side effect, the currency you hold crashes due to inflation. “I want to be happy for the rest of my life!” -&gt; The next 5 minutes you feel very, very happy, then the genie kills you. “I wish for world peace!” -&gt; The genie kills all humans. We wrongly specify the goals either because we don’t know all the constraints or because we can’t measure them. Let’s look at public limited companies as an example of imperfect goal specification: A public limited company has the simple goal of earning money for its shareholders. But this specification does not capture the true goal with all its constraints that we really strive for: For example, we don’t appreciate a company killing people to make money, poisoning rivers or to simply printing its own money. We have invented laws, regulations, penalties, compliance procedures, labor unions and more to patch up the imperfect goal specification. Another example you can live through yourself: Paperclips, a game in which you play a machine with the goal of producing as many paperclips as possible. WARNING: It’s addictive. I don’t want to spoil it too much, but let’s say things get out of hand really quickly. In machine learning, the imperfections in goal specification come from imperfect data abstractions (biased population, measurement errors, …), unconstrained loss functions, lack of knowledge of the constraints, shift in distribution between training and application data and much more. Digitization is driving automation forward. Imperfect goal specification conflicts with automation. I claim that this conflict is mediated by interpretability methods. The scene for our predictions is set, the crystal ball is ready, now let’s take a look where the field could be going! "],
["the-future-of-machine-learning.html", "6.1 The Future of Machine Learning", " 6.1 The Future of Machine Learning Without machine learning, there can be no interpretable machine learning. Therefore we have to guess where machine learning is heading, before we talk about interpretability. Machine learning (or “AI”) is associated a lot of promises and expectations. But let’s start with a less optimistic observation: While science develops a lot of fancy machine learning tools, in my experience it is quite difficult to integrate them into existing processes and products. Not because it’s not possible, but because it simply takes time for companies and institutions to catch up. In the gold rush of the current AI hype, companies open up “AI labs”, “Machine Learning Units” and hire “Data Scientists”, “Machine Learning Experts”, “AI engineers”, and so on, but the reality is rather frustrating (in my experience): Often companies do not even have data in the required form and the data scientist waits inactive for months. Sometimes companies have such high expectation due to the AI hype in the media that the data scientists could never fulfill them. And often nobody knows how to integrate this new kind of people into existing structures and many more problems. That leads to my first prediction: Machine learning will grow up slowly but steadily. Digitization is advancing, and the temptation of automation is constantly pulling. Even if the path of machine learning adoption is slow and stony, machine learning is constantly moving from science to business processes, products and real world applications. I believe we need to better explain to non-experts what types of problems can be formulated as machine learning problems. I know many highly paid data scientists who perform Excel calculations or classical business intelligence with reporting and SQL queries instead of machine learning. But a few companies are already successfully applying machine learning, with the large Internet companies at the forefront. We need to find better ways to integrate machine learning into processes and products, train people and create machine learning tools that are easy to use. I believe that machine learning will become a lot easier to use: We can already see that machine learning becomes more accessible, for example through cloud services (“Machine Learning as a service” - just to spray a few buzz words). Once machine learning has matured - and this has baby already made its first steps - my next prediction is: Machine learning will fuel (almost) everything. Based on the principle “Whatever can be automated will be automated”, I conclude that, whenever possible, tasks will be reformulated as prediction problems and solved with machine learning. Machine learning is a form of automation or can at least be part of it. Many tasks currently performed by humans are being replaced by machine learning. Here are just a few examples: Automation of the sorting / deciding on / filling out documents (e.g. in insurance companies, the legal sector or consulting firms) Data-driven decisions such as credit applications Drug discovery Quality controls in assembly lines Self-driving cars Diagnosis of diseases Translation. I am literally using this right now: A translation service (DeepL) powered by deep neural networks to improve my sentences by translating them from English into German and back into English. … The breakthrough for machine learning is not only achieved through better computers / more data / better software, but also: Interpretability tools catalyze the adoption of machine learning. Based on the premise that the goal of a machine learning model can never be perfectly specified, it follows that interpretable machine learning is necessary to close the gap between the misspecified and the actual goal. In many areas and sectors, interpretability will be the catalyst for the adoption of machine learning. Some anecdotal evidence: Many people I have talked to do not use machine learning because they can’t explain the model to others. I believe that interpretability will tackle this issue and make machine learning attractive to organisations and people that demand a degree of transparency. In addition to the misspecification of the problem, many industries require interpretability, whether for legal reasons, risk aversion or to gain insight into the underlying problem. Machine learning automates the modeling process and moves the human a bit further away from the data and the underlying problem: This increases the risk of problems with design of experiments, choice of training distribution, sampling procedure, data coding, feature engineering, etc. Interpretation tools make it easier to identify these problems "],
["the-future-of-interpretability.html", "6.2 The Future of Interpretability", " 6.2 The Future of Interpretability Let’s take a look at where machine learning interpretability might be going. The focus will be on model-agnostic interpretability tools. It is way easier to automate interpretability if it is decoupled from the underlying machine learning model. The advantage of model-agnostic interpretability is the modularity: We can easily replace the underlying machine learning model. We can just as easily replace the interpretability method. For these reasons, model-agnostic methods will scale much better. That’s why I believe that model-agnostic methods will become more dominant in the long term. But intrinsically interpretable methods will also have their place. Machine learning will be automatic and so will be interpretability. An already visible trend is the complete automation of model fitting: That includes the automated engineering and selection of features, automated hyperparameter optimization, comparison of different models, and ensembling or stacking of the models. The result is the best possible prediction model. When we use model-agnostic interpretation methods, we can automatically apply them on any model that emerges from the automated machine learning process. In a way, we can automate this second step as well: Automatically compute the feature importance, plot the partial dependence, fit a surrogate model and so on. Nobody stops you from automatically computing all these model interpretations. Humans will still be needed for the actual interpretation. Imagine yourself: You only upload a dataset, specify the prediction goal and, at the push of a button, the best prediction model is fitted and the program spits out all interpretations of the model. Solutions already exist and I argue that it will be sufficient for many applications to use these automated machine learning services. Today anyone can build websites without knowing HTML, CSS and Javascript but there are still web developers around. Similarly, I believe anyone will be able to train machine learning models without knowing how to program and there will still be a need for machine learning experts. We don’t analyze data, we analyze models. The raw data itself is always useless (I exaggerate on purpose). I don’t care about the data; I do care about the knowledge distilled from the data. Interpretable machine learning is a great way to distill knowledge from data. You can probe the model extensively, the model automatically recognizes if and how features are relevant to the prediction (many models have built-in feature selection), the model can automatically recognize how the relationships are represented the best and - if trained correctly - the final model is the best possible approximation to reality. Many analytical tools are already based on data models (because they are based on distribution assumptions): Simple hypothesis tests like Student’s t-test. Hypothesis tests with adjustments for confounders (usually GLMs) Analysis of Variance (ANOVA) The correlation coefficient (the standardized linear regression coefficient is the same as Pearson’s correlation coefficient) … So what I am telling you here is actually nothing new. So why switch from analyzing assumption-based, transparent models to analyzing assumption-free black box models? Because making all these assumptions is problematic: They are usually wrong (unless you believe that most of the world follows a Gaussian distribution), difficult to check, very restricting for the relationships the model can represent and hard to automate. Assumption-based models typically have worse predictive performance on untouched test data than black box machine learning models. This is only true for big data sets, since interpretable models with good assumptions will perform better than black box models with many parameters. The black box machine learning approach needs a lot of data to work well. Because of the digitization of everything, we will have bigger and bigger datasets and therefore the approach of machine learning becomes more attractive: We don’t make assumptions, we approximate reality as closely as possible (while avoiding overfitting on the training data). I argue that we should develop all the tools that we have in statistics to answer questions (hypothesis tests, correlation measures, interaction measures, visualization tools, confidence intervals, p-values, prediction intervals, probability distributions) and rewrite them for black box models. In a way, this is already happening: Let’s take a classic linear model: The standardized regression coefficient is already a feature importance measure. With the permutation feature importance measure, we have a tool that works with any model. In a linear model, the coefficients measures the effect of a single feature on the predicted outcome. The generalized version of this is the partial dependence plot. Test whether A or B is better: For this we can also use partial dependence functions. What we don’t have yet (to the best of my best knowledge) are statistical tests for arbitrary black box models. The data scientists will automate themselves. I believe that data scientists will eventually automate themselves out of the job for many analysis and forecasting tasks. For this to happen the tasks must be well-defined and there must to be some processes and routine around them. Today, these routines and processes are missing, but data scientists and colleagues are working on them. As machine learning becomes an integral part of many industries and institutions, many of the tasks that are currently being figured out will be automated. Robots and programs will explain themselves. We need more intuitive interfaces to machines and programs that make heavy use of machine learning. Some examples: A self-driving car that reports why it stopped abruptly (“70% probability that a kid will cross the road”); A credit default program that explains to a bank employee why a credit application was rejected (“Applicant has too many credit cards and is employed in an unstable job.”); A robot arm that explains why it moved the item from the conveyor belt into the trash bin (“The item has a craze at the bottom.”). Interpretability could boost machine intelligence research. I can imagine that by doing more research on how programs and machines can explain themselves, we can improve improve our understanding of intelligence and we will become better at creating intelligent machines. In the end, all these predictions are speculations we have to see what the future really brings. Form your own opinion and continue learning! "],
["contribute.html", "Chapter 7 Contribute", " Chapter 7 Contribute Thanks for reading this book on Interpretable Machine Learning. The book is under continuous development, it will be improved over time, and chapters will be added. You are very welcome to contribute by, for example, writing a chapter, adding plots or fixing typos! All of the code for the book is open source and available on github.com. On the Github page, you can propose fixes to the code or open issues if you find some mistakes or that something is missing. The issues page is also the place for finding easy problems to get started with contributing. For bigger contributions, please send me a message: christoph.molnar.ai@gmail.com. "],
["acknowledgements.html", "Chapter 8 Acknowledgements", " Chapter 8 Acknowledgements Writing this book was (and still is) a lot of fun. But it’s also a lot of work and I am very happy about the support I received: A special thanks goes to Verena Haunschmid for contributing the section about LIME explanations for images. She works in data science and I recommend following her on Twitter: @ExpectAPatronum. I also want to thank all the early readers who contributed smaller fixes on github! Further, I want to thank everyone involved in creating illustrations: The cover was designed by my friend @ArbeitAmText. The graphics in the Shapley Value chapter were made by Abi Aryan, using icons made by Freepik from . The awesome images in the chapter about the future of interpretability are designed by @TopeconHeroes. Verena Haunschmid created the graphic in the RuleFit chapter. I am grateful for the funding of my research on interpretable machine learning by the Bavarian State Ministry of Science and the Arts in the framework of the Centre Digitisation.Bavaria (ZD.B). "]
]
