```{r, message = FALSE, warning = FALSE, echo = FALSE}
devtools::load_all()
set.seed(42)
```

## Accumulated Local Effects (ALE) {#ale}

Accumulated Local Effects [^ALE] plots show how a single feature (or of two features) affect predicted outcome of a machine learning model on average.
ALE Plots are an alternative to the [partial dependence plots](#pdp) (PDPs) and the bias of PDPs when features are correlated.

*Keywords: partial dependence plots, PDP, PD plot, marginal means, predictive margins, marginal effects, ALE plot*

**The Problem: Correlated features**

When features of a machine learning model are correlated, the partial dependence plot cannot be trusted.
Calculating the partial dependence plots for correlated features involves creating and averaging over data instances that are unlikely in reality.
This can bias the resulting effect heavily.
For example, we compute the partial dependence plots for a  machine learning model that predicts the worth of a house depending on the number of rooms and the size of the living area.
We calculate the partial dependence plot for the living area.
To compute the first grid value - let's say a living area of 30 square meters - we replace the living area for all instances with 30, even for houses with 10 rooms.
Sounds like a very unlikely house to me, but in partial dependence plots with correlated features, these instances are created and used for computing the averages, biasing the interpretation.
For interpreting what the model on average predicts, the partial dependence plots includes these unrealistic houses into it's calculation and pretend that that behaviour is ok.
The following plot gives an impression of that problem.

```{r aleplot-motivation1, fig.cap = "Two strongly correlated features x1 and x2. To compute the partial dependence at x1 = 0.75, the PDP averages the prediction over the whole range of x2."}

set.seed(1)
n = 100
intercept = 0.75

x1 = runif(n)
x2 = x1 + rnorm(n, sd = 0.1)
df = data.frame(x1, x2)  

p = ggplot(df) + geom_point(aes(x = x1, y = x2)) +  
  theme(panel.grid.major.y = element_blank(), 
    panel.grid.minor.y = element_blank(), 
    panel.grid.major.x = element_blank(), 
    panel.grid.minor.x = element_blank())

p.int = p + geom_vline(xintercept = intercept)
x1.dens = density(x1)
x1.dens.df = data.frame(dens = x1.dens$y, x = x1.dens$x)


p1 = p.int + geom_path(data = x1.dens.df, aes(x = intercept - dens/10, y = x)) + 
  ggtitle(sprintf("Marginal distribution p(x2)", intercept)) + 
  scale_y_continuous(limits = c(-0.2, 1.2))
p1
```
What can we do to get a better estimate how a feature influences the prediction?

The problem of partial dependence plots with correlated features stems from the fact that PDPs average over the marginal distribution of features, which kind of assumes that the features are independent.
A first step to improvement is to use the conditional distribution of features,  meaning for each grid value, we only look at the predictions of nearby data instances.
Given the living area is 30 square meters, what is the average prediction?
The solution for computing feature effects using the the conditional distribution is called Marginal Plots, or M-Plots (confusing naming, I know).
Wait, what?
Didn't I promise to talk about ALE Plots?
Where are M Plots coming from?
M Plots are not the solution, but a step into the right direction with ALE Plots as the final solution.
Why are M-Plots not solving our problem?
If we average over all houses that are around 30 square meters, we don't get the pure effect of the living area, but also the effect of the number of rooms, because of their correlation.
Assume that the living area itself has no effect on the predicted worth of a house, only the numbers of rooms have.
The M-Plot would still show that the size of the living affects the prediction, since we use the conditional distribution and the number of rooms grows with the living area, so we mix up both effects.
The following plot shows how M-Plots work:

```{r aleplot-motivation2, fig.cap = "Two strongly correlated features x1 and x2. M-Plots average only over the conditional distribution, here shown conditional on x1 = 0.75. Also ALE-Plots are based on the conditional distribution, but acumulate the average (conditional) change in prediction."}

set.seed(1)
n = 100
intercept = 0.75

x1 = runif(n)
x2 = x1 + rnorm(n, sd = 0.1)
df = data.frame(x1, x2)  

p = ggplot(df) + geom_point(aes(x = x1, y = x2)) +  
  theme(panel.grid.major.y = element_blank(), 
    panel.grid.minor.y = element_blank(), 
    panel.grid.major.x = element_blank(), 
    panel.grid.minor.x = element_blank())

p.int = p + geom_vline(xintercept = intercept)
x1.dens = density(x1)
x1.dens.df = data.frame(dens = x1.dens$y, x = x1.dens$x)


p1 = p.int + geom_path(data = x1.dens.df, aes(x = intercept - dens/10, y = x)) + 
  ggtitle(sprintf("Marginal distribution p(x2)", intercept)) + 
  scale_y_continuous(limits = c(-0.2, 1.2))

x1.dens.ale = density(x1[(x1 > (intercept - 0.1)) & (x1 < (intercept + 0.1))])
x1.dens.ale.df = data.frame(dens = x1.dens.ale$y, x = x1.dens.ale$x)

p2 = p.int + geom_path(data = x1.dens.ale.df, aes(x = intercept - dens/20, y = x)) + 
  ggtitle(sprintf("Conditional distribution p(x2|x1=%.2f)", intercept)) + 
  scale_y_continuous(limits = c(-0.2, 1.2))
p2
```


We solve the problem of averaging over unlikely data points, but our effect estimate is now mixing up the effects of two features.
This problem can be overcome by computing local effects in the form of differences, conditional on the distribution.
This mean for the effect of 30 square meter houses, we first condition on similar small houses and instead of averaging their predictions (M-Plots) we compute the difference in prediction when we would increase the living area for these houses slightly (the slope or gradient of the price dependent on the living area).
In this way, we get the pure effect of the living area, conditional that living area is small and without mixing the effect up with the effects of any correlated features.
The solution also has a name: ALE plots, which is short for [Accumulated Local Effects (ALE) Plots](#ale).
The following graphic show how the ALEplots are calculated. 


```{r aleplot-computation, fig.cap = "For the computation of ALE plots, we first divide the feature into intervals (vertical lines). In each interval, we select the data instances (points) and compute the difference in prediction when we replace the feature with the upper and lower limit of the interval (horizontal lines). Not shown in the plot: These difference are later cumulated and centered, which yields the ALE curve."}

set.seed(12)
n = 25

x1 = runif(n)
x2 = x1 + rnorm(n, sd = 0.1)
df = data.frame(x1, x2)  

p = ggplot(df) + geom_point(aes(x = x1, y = x2)) +
  theme(panel.grid.major.y = element_blank(), 
    panel.grid.minor.y = element_blank(), 
    panel.grid.major.x = element_blank(), 
    panel.grid.minor.x = element_blank()) 


grid.df = data.frame(x1 = seq(from = 0,  to = 1, length.out = 6)[1:6], x2 = NA)
label.df = grid.df[1:5,]
label.df$x1 = label.df$x1 + 0.1
label.df$x2 = 0.95
label.df$label = sprintf("N1(%i)", 1:5)

break.labels = c(expression(z[0~","~1]),  expression(z[1~","~1]), expression(z[2~","~1]), expression(z[3~","~1]),
  expression(z[4~","~1]), expression(z[5~","~1]))

diff.df = df[df$x1 <= 0.8 & df$x1 > 0.6, ]

p + geom_vline(data = grid.df, aes(xintercept = x1), linetype = 3) + 
  scale_x_continuous(breaks = seq(from = 0,  to = 1, length.out = 6), limits = c(0, 1), labels = break.labels) + 
  geom_label(data = label.df, aes(x = x1, y = x2, label = label)) + 
  geom_segment(data = diff.df, aes(x = 0.6, xend = 0.8, y = x2, yend  = x2), arrow = arrow(ends = "both", angle = 90, length = unit(0.07, "inches")))
```


To summarizes how each type of plot handles the effect of a feature j at a certain grid value v:  
Partial Dependence Plots: "Let me show you what the model predicts on average if every data instance had value v for feature j. I don't care if value v is a meaningful value for the other data instances".  
M-Plots: "Let me show you what the model predicts on average for data instances that have values close to v for feature j. I can't promise you that the averages you see are from feature j or from some correlated feature".  
ALE Plots: "Let me show you how the model predictions change when we slightly increase value v for data instances that have values close to v for feature j".

### Theory

**How do PD, M and ALE Plots compare mathematically?**

All plots have in common that they reduce our complex prediction function f to one or two dimensions, depending on the feature(s) we choose.
They also have in common that they estimate the expectation of the model prediction function, but differ fo what they compute the expectation (f or derivative of f) and over what distribution (marginal or conditional).

Partial dependence plots average the predicted outcome over the marginal distribution.

$$\hat{f}_{x_S,PDP}(x_S)=E_{X_C}\left[\hat{f}(x_S,X_C)\right]=\int_{x_C}\hat{f}(x_S,x_C)\mathbb{P}(x_C)d{}x_C$$

That's the value of our prediction function f, at $x_S$, averaged over all features in $x_C$.
Because we are only interested in the effect of $x_S$ on the prediction, we need to average out the effects of the other features, which get the index C here. 
Averaging out means computing their marginal expectation E here, which is the integral over the prediction weighted by the probability distribution.
Sounds fancy pants, but when it gets down to computing this, we simply take all our data, get their prediction by forcing them to have a certain (grid) values for our feature ov interest, and average over the predictions.
By taking the data we have, this already ensures that we average over the distribution of the features.

M plots average the predicted outcome over the conditional distribution:

$$\hat{f}_{x_S,M}(x_S)=E_{X_C|X_S}\left[\hat{f}(X_S,X_C)|X_S=x_s\right]=\int_{x_C}\hat{f}(x_S,x_C)\mathbb{P}(x_C|x_S)d{}x_C$$
The only thing that changes compared to PDPs is that we take the average of the data instance not over all the data, but conditional on a certain grid point at which we are with the feature of interest.
In practice this means that we have to define a neighbourhood and average over it, for example for the effect of 30 square meters, we average over all houses between 28 and 32 square meters.

ALE Plots average the change in the predicted outcome and acumulate it over the grid (more on the computation later).

$$\hat{f}_{x_S,ALE}(x_S)=\int_{z_{0,1}}^{x_S}E_{X_C|X_S}\left[\hat{f}^S(X_s,X_c)|X_S=z_S\right]dz_S-constant\\=\int_{z_{0,1}}^{x_S}\int_{x_C}\hat{f}^S(z_s,x_c)\mathbb{P}(x_C|z_S)d{}x_C{}dz_S-constant$$


There are three differences to M Plots. 
First, we do not average over the prediction, but we average over the change of prediction, represented by the gradient:


$$\hat{f}^S(x_s,x_c)=\frac{\delta\hat{f}(x_S,x_C)}{\delta{}x_S}$$

The second difference is the additional integral that integrates over some z.
That's because we acumulate these local gradient effects over the range of $x_S$, which gives us the effect of the feature on the prediction.
The z's indicate that we acumulate the effects over some intervals, where in each of them we compute this changes in prediction.
The third difference is that we subtract some constant from the results.
The constant is here to center the ALE, so that they are zero on average.
Let's dive a bit deeper into ALE Plots computation:

**How to compute the ALE Plots**

ALE plots are plots for estimates of the first order (1D) or second order (2D) effects of features on the prediction.
An ALE plot for feature $x_j$ is the accumulated integral of the expected gradient of the prediction over intervals of $x_j$.
Instead of directly computing the average of the function, the ALE method calculates the derivative in each interval and integrates again over the derivative to get the value of the function. 
Now, that sounds stupid. 
Derivation and integration cancel each other out, like first subtracting, then adding the same number. 
Why does this make sense?
Because the derivative is computed at different grid values and averages the effects locally, avoiding the mistake of partial dependence plots of averaging over the marginal distribution which is so problematic when the features are correlated.
It also avoids the mistakes of M Plots that we mix up our effect estimates with the effect that correlated features have on the predicted outcome.
One problem remains for how I described ALE Plots so far: 
Not all models come with a gradient, for example random forests have no gradient.
For the actual estimation of the local effects, we divide the feature into many intervals and compute the differences in the prediction.
This approximates the gradients, but is also computable for models without gradients.

First we have to estimate the uncentered effect, here for a single feature: 

$$\hat{\tilde{f}}_{j,ALE}(x)=\sum_{k=1}^{k_j(x)}\frac{1}{n_j(k)}\sum_{i:x_{i,j}\in{}N_j(k)}\left[f(z_{k,j},x_{i\setminus{}j})-f(z_{k-1,j},x_{i\setminus{}j})\right]$$
Let's break this formula down, starting from the right side. 
The name *Acumulated Local Effects* nicely reflects all individual components of this formula.
At it's heart, the ALE Plot computes the differences in predictions, where we replace the feature we are interested in with grid values z.
This difference in prediction is the *Effect* (in ALE) the feature has for an individual instance in a certain interval.
The inner sum is the sum over all instances within one interval, indicated as neighbourhood N(k).
We divide this sum by the number of instances that are in this interval, to get the mean difference in the prediction for that interval.
This average in the interval reflects the *Local* in the name ALE.
The left sum symbol means that we acumulate this mean prediction difference over all intervals.
The (uncentered) ALE at a feature value that lies in the third interval is the sum of the effects of the first, second and third interval.
The *Acumulated* in ALE comes from this outer sum.

This effect is then centered, so that the mean effect is zero:

$$\hat{f}_{j,ALE}(x)=\hat{\tilde{f}}_{j,ALE}(x)-\frac{1}{n}\sum_{i=1}^{n}\hat{\tilde{f}}_{j,ALE}(x_{i,j})$$

The value of the ALE can be interpreted as the effect of the feature at a certain feature value compared to the mean. 
For example if the curve at $x_j=3$ is -2, it means that when $x_j$ has value 2, then the prediction is lower by 2 compared to the average prediction.

One thing I haven't spoken about yet is how to choose the grid.
While many solutions are admissable, like random selection or uniform grid, the one that makes most sense are quantiles of the distribution of the feauture.
Using the quantiles assures that there are roughly the same amount of data points in each of the intervalls. 
Quantiles have the drawback that the intervals can have very different lenghts.
This can result in some weird ALE plots, when the feature of interest is very skewed, for example lots of low values and just a few very high values.
Then the intervals in the beginning are very short and much larger for higher values.


**Demonstration that ALE Plots fix correlation problem**

Let's see ALE Plots now in action. 
I created a scenario in which the partial dependence plot fails, consisting of two features, one outcome to predict and a prediction model.
The features are strongly correlated and the prediction model does something weird at a combination of the two features for which we never observed instances.
The following figure shows how this scenario looks like.


```{r correlation-problem, fig.cap = "Two features and a predicted outcome. The model simply predicts the sum of the two features (shaded background), but there is also some artifact where the model always predicts 2, when x1 is larger than 0.7 and x2 smaller than 0.3. This artifact lies far away from the distribution of the data and are as such unrealistic values, so this artifact shouldn't affect our interpretation of the model."}

set.seed(12)
n = 25

x1 = runif(n)
x2 = x1 + rnorm(n, sd = 0.1)
df = data.frame(x1, x2)  
df$y = x1 + x2

mod  = lm(y ~ ., data = df)

y.fun = function(X.model, newdata) {
  pred = predict(X.model, newdata)
  pred[newdata$x1 > 0.7 & newdata$x2 < 0.3] = 2
  pred
}

grid.dat = expand.grid(x1 = seq(from = 0, to = 1, length.out = 20), x2 = seq(from = 0, to = 1, length.out = 20))
grid.dat$predicted = y.fun(mod, grid.dat)

ggplot(df) + geom_tile(data = grid.dat, aes(x = x1, y = x2, fill = predicted)) + 
  geom_point(aes(x = x1, y = x2), size = 3) + 
  scale_fill_gradient(low = "white", high = "blue")
```

"This is a completely made up example", I here some angry people yelling.  
"What kind of model would do such a thing?! Unrealistic!", other join.  
Yes, this is a toy example.  
BUT, remember that, when you train a model, the model only fits the existing data points. 
Anything can happen outside of the distribution of the training data, depending on the type of model, because the model will not be penalized for doing weird stuff abroad.
Since we optimize the model based on the training data, anything can happen outside of that distribution.
That's how we can generate [adversarial examples](#adversarial).
Linear models for example have extreme behaviour outside the distribution of the data, because they are linear functions. 
Imagine a linear regression model for predicting the worth of a house which has a postive weight for the influence of the living area.
Going outside the data means going beyond certain levels of square meters (let's say 3000) will make your predictions grow extreme.
The phenomenon is called extrapolation and that's also what's happening when you have correlated features with partial dependence plots.
Extrapolation leads to values that are very unlikely given the distribution of our training data.
See what happens with the PD plots and how they compare to the ALE plots in our little example:


```{r correlation-pdp-ale-compute, include = FALSE}
library(ALEPlot)
pred = Predictor$new(mod, data = df, predict.fun = y.fun)
pdp = Partial$new(pred, feature = "x1", ice = FALSE)
pdp1 = pdp$plot() + ggtitle("PDP")
pdp = Partial$new(pred, feature = "x2", ice = FALSE)
pdp2 = pdp$plot() + ggtitle("PDP")

ale1.df = data.frame(ALEPlot(df, mod, J = "x1", pred.fun = y.fun))
ale1 = ggplot(ale1.df) + geom_line(aes(x = x.values, y = f.values)) + 
  scale_x_continuous("x1") + scale_y_continuous(expression(hat(y))) + 
  ggtitle("ALE plot")
ale2.df = data.frame(ALEPlot(df, mod, J = "x2", pred.fun = y.fun))
ale2 = ggplot(ale2.df) + geom_line(aes(x = x.values, y = f.values)) + 
  scale_x_continuous("x2") + scale_y_continuous(expression(hat(y))) + 
  ggtitle("ALE plot")
```


```{r correlation-pdp-ale-plot, fig.cap = "Comparing the feature effects computed with PDP and ALE. The PDP picks up on the artifact in the data (steep jumps in the plots), which lies outside of the data distribution. The ALE plot correctly identifies that the machine learning model has a linear relationship between features and prediction, ignoring areas where no data instances lie"}
gridExtra::grid.arrange(pdp1, pdp2, ale1, ale2)
```


In the area of our training data, the model is simply a linear model, which the ALE Plots capture nicely.
The PDP plots, extrapolating into areas they shouldn't extrapolate, pick up the model artefact and give us a very weird impression of what the model does.
But is it not interesting to see that our model makes something weird?
Well, yes and no.
These data instances might be physically impossible or at least extremely unlikely, then I don't see how looking into these instances might be interesting. 
But if you suspect that you had this correlation between the training instances, but your test distribution might be somewhat different and some instances may actually lie in this area, then it would be interesting. 
But this has to be a deliberate choice to include areas where we haven't observed any data yet and not a side-effect of the method.
I recommend to still use ALE Plots, but generate the data you are expecting by simulating it for example, instead of relying on a flawed method.



**ALE Plots for two features**

ALE plot can also be used with more features, but, as with PDP, only makes sense with two at maximum and current software implementation allow only two at maximum.
The principles are the same as with a single feature, but we now work with rectangular cells instead of intervals, because we have to accumulate the effects in two dimensions.
Also, we don't only adjust for the overall mean prediction, but for the the accumulated local effects of the single features.
This means that the ALE for two features represents the second-order effects and doesn't include the first-order effect.
This means that ALE for two features only shows the additional interaction effect of the two features, where the main effects of the features was subtracted.
Conceptually that's same thing we did for the single feature ALE, where we subtracted the overall mean, only extended now to the next dimension.
If we would compute the 3-feature ALE, then we would subtract all the 2-feature ALE.
I'll spare you with the formula for 2D ALE plots, as it is long and uncomfortable to read.
If you are interested, I refer to the paper, formulas (13) - (16) for the computation.
Let's go for some visual intuition how it is computed: 

```{r aleplot-computation-2d, fig.cap = "Illustration on how to calculate second-order Accumulated Local Effects for two features. We lay a grid over the two features we are interested in. In each cell of that grid (one is exemplary highlighted), we compute the second-order differences, which is the joint effect (indicated by an arrow from bottom left to top right of the cell) minus the two first order effects, as indicated by the vertical and horizontal arrows next to the cell and minus the overall weighted mean prediction of the cells. In each cell the effects are averaged for the points within that cell."}

p = ggplot(df) + geom_point(aes(x = x1, y = x2)) +
  theme(panel.grid.major.y = element_blank(), 
    panel.grid.minor.y = element_blank(), 
    panel.grid.major.x = element_blank(), 
    panel.grid.minor.x = element_blank()) 


grid.df1 = data.frame(x1 = seq(from = min(df$x1),  to = max(df$x1), length.out = 6)[1:6], x2 = NA)
grid.df2 = data.frame(x2 = seq(from = min(df$x2),  to = max(df$x2), length.out = 6)[1:6], x1 = NA)

chosen.tile = data.frame(x = grid.df1$x1[4], xend = grid.df1$x1[5], y = grid.df2$x2[4], yend = grid.df2$x2[5])

mv.arr = 0.02
p + geom_vline(data = grid.df1, aes(xintercept = x1), linetype = 3) + 
  geom_hline(data = grid.df2, aes(yintercept = x2), linetype = 3) + 
  geom_rect(aes(xmin = x, xmax = xend,  ymin = y, ymax = yend), data = chosen.tile, alpha = 0, color = "black", size = 1.1) + 
  geom_segment(data = chosen.tile, aes(x = x, xend = xend, y = y, yend = yend), arrow = arrow(angle = 10)) + 
    geom_segment(data = chosen.tile, aes(x = x - mv.arr, xend = x - mv.arr, y = y, yend = yend), arrow = arrow(angle = 10)) + 
    geom_segment(data = chosen.tile, aes(x = x, xend = xend, y = y - mv.arr, yend = y - mv.arr), arrow = arrow(angle = 10))  
```

When spanning the grid, which is the cartesian product of the quantiles of both features, some cells might remain empty, especially when the features are correlated. 
In the example in the figure before, many cells were empty because of the correlation.
In this case, the ALE can either be omitted and visualized with a greyed or blacked out box. 
Alternatively, you can replace the missing ALE of an empty cell by the ALE estimate of the nearest non-empty cell.
Is this problem distinct from the extrapolation problem that PDPs have?
Yes, for PDPs these empty areas are involved in estimating first-order univariate effects, which biases the estimates.
For ALE plots the empty cells only play a role in second-order effects and when a cell is empty it can also be indicated by plotting points where data lie into the plot to make it clear.

Since the ALE estimates for two features only show the second-order effect of the features, the interpretation needs some extra attention.
The second-order effect is the additional interaction effect of the features, after we have accounted for the main effects of the features and the mean effect.
Let's say two features don't interact, but each has a linear main-effect on the predicted outcome. 
In the 1D ALE plot for each feature we will see a straight line as the estimated ALE curve, with the slope equal to the estimated weight when the underlying model was a linear model.
But when we plot the 2D ALE estimates, they should be close to zero, because the second-order effect is only the additional effect of the interaction, which is zero in our little example.

The Accumulated Local Effects can also be computed for arbitrary higher orders (combinations of more than two features), but as argued in the [PDP chapter](#pdp), only up to 2D makes sense, because higher interactions can't be visualized meaningfully.


**What happens with categorical features?**

Accumulated Local Effects need - by definition - an order within a feature to work, because it has to accumulate the effects in some direction.
Categorical features - by definition - don't have any order.
So no ALE plots for categorical features, I am sorry.
Just kidding.
Once you have ordered the categories and enumerate them, you can compute ALE.
But how can we meaningfully order the categories?
Some categorical features have a natural order, for example grades in school or hierarchy ranks in a company.
For those it might make sense to keep that order, but for other features like the season or color there is no obvious order.
Then there are some features like the day of the week (Monday, Tuesday, ...) which look like they have an order, but it's not clear if you want to use that order for computing ALE plots. 
Where do we start? Monday? Sunday?)
For some prediction model Mondays might be more similar to Thursdays than to Tuesdays.

The order of the categories influences the interpretation and calculation of the accumulated local effects.
One solution is to order the categories based on how similar the categories are.
For a given category, the next 'lower' and the next 'larger' categories in the ordering should be similar and the farther you move a way from the category, the more dissimilar the categories should be.
How can we compute the similarity of categories?
A solution is to measure how different the instances of different categories in their feature values of the other features.


Here a short pseudo-code for calculating ALEs for categorical features.

Goal: Compute the distances between two categories.
Input: Instances from category 1 and 2

1. For all features, do (excluding the categorical feature for which we are computing the order):
   - If the feature is numerical: Take instances from category 1, calculate the empirical cumulative probability distribution function (ecdf) of the feature. The ecdf is a function that tells us for a given feature value, how many values are smaller. Do the same for category 2. The distance is the absolute maximum point-wise distance of the two ecdf. Practically, this value is high when the distribution from one category is strongly shifted far away from the other. This measure is also known as the [Kolmogorov-Smirnov distance](https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test). 
   - If the feature is categorical: Take instances from category 1 and calculate a table with the relative frequency of each category of the other feature. Do the same for instances from category 2. The distance is the sum of the absolute difference of both relative frequency tables.
2. Sum up the distances over all features

This algorithm we run for all pairs of categories.
Then we have a k times k matrix, when k is the number of categories, where each entry is the distance between two categories.
Still not enough to have a single order, because, a (dis)similarity tells you the pair-wise distances, but does not give you a one-dimensional ordering of the classes.
To kind of force this thing into a single dimension, we have to use a dimension reduction trick called multi-dimensional scaling. 
This can be solved using multi-dimensional scaling, which takes in a distance matrix and returns a distance matrix with reduced dimension.
In our case, we only want 1 dimension left, so that we have a single ordering of the categories and can compute the accumulated local effects.
After reducing it to a single ordering, we are done and can use this ordering to compute ALE.
This is not the holy grale how to order the factors, but one possibility.

To make is a bit clearer, here is one example:
Let's say with have two categorical features (season and weather) and one numerical (temperature).
For the first categorical feature we want to calculate the ALEs. 
The feature has the categories "Spring", "Summer", "Fall", "Winter".
The numerical feature is temperature, and the other categorical feature is the type of weather with categories "good", "misty", "rainy".
We start to compute the distance between categories "Spring" and "Summer". 
The distance is the sum of distance over the features temperature and weather.
For temperature, we take all instances with "Spring", compute the empirical cumulative distribution function and do the same for instances with "Summer" and compare both with Kolmogorov-Smirnov test statistic.
For the weather feature, we compute for all "Spring" instances the probabilities for each weather type, do the same for the "Summer"-instances and sum up the absolute distance in the probability distribution.
If "Spring" and "Summer" have very different temperatures and weather, the distance will be large.
We repeat the procedure with the other season pairs, which results in the distance matrix, which is then reduced to a single dimension using multi-dimensional scaling.

TODO: CONTINUE HERE


### Examples

It's time to predict [bike rentals](#bike-data) dependent on weather and day
We fit a regression tree model for this.
We first fit a machine learning model on the dataset, for which we want to analyse the partial dependencies.
In this case, we fitted a RandomForest to predict the bike rentals and use the partial dependence plot to visualize the relationships the model learned.
The influence of the weather features on the predicted bike counts:

```{r ale-bike-train, fig.cap = 'Partial dependence plots for the rental bike prediction model and different weather measurements (Temperature, Humidity, Windspeed). The biggest differences can be seen in the temperature: On average, the hotter the more bikes are rented, until 20C degrees, where it stays the same also for hotter temperatures and drops a bit again towards 30C degrees. The marks on the x-axis indicate the distribution of the feature in the data.'}
data(bike)
library("mlr")
library("ggplot2")

set.seed(42)
bike.task = makeRegrTask(data = bike, target = "cnt")
mod.bike = mlr::train(mlr::makeLearner(cl = 'regr.ctree'), bike.task)$learner.model

pred.bike = Predictor$new(mod.bike, data = bike, y = "cnt")
```

```{r ale-bike-prep, fig.keep = FALSE, include = FALSE}
y.fun = function(X.model, newdata) {
 X.model$predict(newdata)[[1]]
}

limits = c(-1500, 800)

ale1.df = data.frame(ALEPlot(bike, pred.bike, J = "temp", pred.fun = y.fun))
ale1 = ggplot(ale1.df) + geom_line(aes(x = x.values, y = f.values)) + 
  scale_x_continuous("temp") + scale_y_continuous(expression(hat(y)), limits = limits)
ale2.df = data.frame(ALEPlot(bike, pred.bike, J = "hum", pred.fun = y.fun))
ale2 = ggplot(ale2.df) + geom_line(aes(x = x.values, y = f.values)) + 
  scale_x_continuous("hum") + scale_y_continuous(expression(hat(y)), limits = limits)

ale3.df = data.frame(ALEPlot(bike, pred.bike, J = "windspeed", pred.fun = y.fun))
ale3 = ggplot(ale3.df) + geom_line(aes(x = x.values, y = f.values)) + 
  scale_x_continuous("windspeed") + scale_y_continuous(expression(hat(y)), limits = limits)
```

```{r ale-bike, fig.cap = "ALE  plots for the rental bike prediction model and different weather measurements (Temperature, Humidity, Windspeed). The overall tendencies are similar to partial dependence plots. One difference is that the effects are centered at 0. For very high temperature or humidity, the ALE and PD plot differ. The ALE plot detects much larger negative effects on the predicted bike rentals when it's very hot or very humid."}
gridExtra::grid.arrange(ale1, ale2, ale3, ncol = 3)
```

Let's look at the correlation of the feature temperature, humidity and windspeed.

```{r ale-bike-cor}
kable(cor(bike[c("temp", "hum", "windspeed")]), digits = 2)
```

They are a bit correlated, but not strongly, so when we use a partial dependence plot, it should also yield reasonable results.

```{r pdp-bike-compare, fig.cap = "Partial dependence plots for the features temperature, humidity and windspeed. Compared to the ALE plots, the PDPs show a smaller drop in bike rentals for high temperature or high humidity. The PDP uses all data points for calculating the effect of high temperature for example, even for instances with season 'winter' for example, so the results of the ALE plot are more reliable."}
pdp = Partial$new(pred.bike, "temp", ice = FALSE) 
p1 = pdp$plot() +  scale_x_continuous('Temperature') + scale_y_continuous('Predicted number of bike rentals', limits = c(3700, 5300))
pdp$set.feature("hum")
p2 = pdp$plot() +  scale_x_continuous('Humidity') + scale_y_continuous('', limits = c(3000, 5500))
pdp$set.feature("windspeed")
p3 = pdp$plot() + scale_x_continuous('Windspeed') + scale_y_continuous('', limits = c(3000, 5500))

gridExtra::grid.arrange(p1, p2, p3, ncol = 3)
```


ALE plots also work for categorical features.

```{r ale-bike-cat-prep, include = FALSE}
alecat1.df = data.frame(ALEPlot(bike, pred.bike, J = "weathersit", pred.fun = y.fun))
alecat1 = ggplot(alecat1.df) + geom_col(aes(x = x.values, y = f.values)) + 
  scale_x_discrete("Weather situation") + scale_y_continuous(expression(hat(y)))
```

```{r ale-bike-cat, fig.cap = "ALE plots for categorical feature weather situation. Weather categories are ordered by their similarity to each other, based on the distributions of the other features within each weather category. For good weather the predicted number of bikes is almost 600 bikes larger, compared to misty or worse weather. The underlying model treats misty and rainy weather equally."}
alecat1
```


Next we look at the second-order effect of humidity and temperature on the predicted number of bike rentals. 
Remember that the second-order effect is the additional interaction effect of the two features and does not cover the first-order effects. 
This means that you won't see the for example the trend that high humidity causes less rented bikes.

```{r ale-bike-2d, fig.cap = 'Accumulated Local Effects Plot for the second-order effect of humidity and temperature on the predicted number of bike rentals. Yellow color indicates above average and red color below average number of predicted bike rentals. The plot reveals an interaction between temperature and humidity: Hot and humid weather increases the number of bike rentals (keep in mind that both first-order effects of humidity and temperature say that the number of bike rentals are decreased when hot and humid). So for hot and humid weather, the joint effect of temperature and humidity is not the sum of the first-order effects, but actually less. Fpr cold and humid weather, an additional negative effect on the number of predicted bike rentals is shown. '}
x = ALEPlot::ALEPlot(bike, pred.bike, J = c("hum", "temp"), pred.fun = y.fun, K = 100)
```

To emphasize again the difference between the pure second-order effect (the 2D ALE plot) and the total effect, let's look at what the partial dependence plot shows.
The partial dependence plot for two features combines the first-order and second-order effects.

```{r pdp-bike-vs-ale-2D, fig.cap = "Partial dependence plot of the effect of temperature and humidity on the predicted bike rentals. The plot combines the main effect of each of the features and their interaction, unlike the 2D-ALE plot which only shows the interaction."}
pdp = Partial$new(pred.bike, c("hum", "temp"))
pdp$plot() + scale_fill_gradient(low = "red", high = "yellow")
```
When you are only interested in the interaction, the way of the ALE plot is better. 
But if you want to read out the combined effect of the features, then the way of the 2D PDP is better, since it combines main effects and interaction. 
If you want to know what the expected number of bike rentals is at 30 degrees Celsius and 80 percent humidity, you can directly read it from the 2D PDP. 
When you want to know the same thing using ALE plots, than you have to look at three plots: The ALE plot for temperature, for humidity and for temperature + humidity.
On the other hand, when two features have no interaction, only plotting the second-order effect will reveal just that. 
When the first-order effects are included, the 2D plot will show something and it is not easy to spot weather the features interact or not (but you can see it if you practice).


Enough bikes for now, let's turn to classification.
We train a random forest to predict the probability for [cervical cancer](#cervical) for a woman dependent on risk factors.
For the random forest we visualize the Accumulated Local Effects for two of the features:

```{r ale-cervical-prep, fig.keep = FALSE, include = FALSE}
data(cervical)
cervical.task = makeClassifTask(data = cervical, target = "Biopsy")
mod = mlr::train(mlr::makeLearner(cl = 'classif.randomForest', id = 'cervical-rf', predict.type = 'prob'), cervical.task)

pred.cervical = Predictor$new(mod, data = cervical, class = "Cancer")
ale1.df = data.frame(ALEPlot(cervical, pred.cervical, J = "Age", pred.fun = y.fun))
ale1 = ggplot(ale1.df) + geom_line(aes(x = x.values, y = f.values)) + 
  scale_x_continuous("Age") + scale_y_continuous(expression(hat(y))) 

ale2.df = data.frame(ALEPlot(cervical, pred.cervical, J = "IUD..years.", pred.fun = y.fun))
ale2 = ggplot(ale2.df) + geom_line(aes(x = x.values, y = f.values)) + 
  scale_x_continuous("Hormonal.Contraceptives..years.") + scale_y_continuous(expression(hat(y))) 

```

```{r ale-cervical-1D, fig.cap = "ALE plots of cancer probability and the risk factors age and number of years with hormonal contraceptives. For the age feature, the partial dependence plot shows that on average the cancer probability is until 40 and increases after that. The sparseness of data points after age of 50 indicates that the model did not have many data points to learn from above that age. The number of years on hormonal contraceptives is associated with a higher cancer risk after 10 years. But again, there are not many data points in that region, which implies that we might not be able to rely on the machine learning model predictions for >10 years on contraceptives "}
gridExtra::grid.arrange(ale1, ale2, ncol = 2)
```

Now let's look at the interaction between number of pregnancies and age, as we did in the partial dependence chapter.


```{r ale-cervical-2d, fig.cap = 'Accumulated Local Effects Plot for the second-order effect of number of pregnancies and the age on the predicted risk of cancer. We see a little bit of interaction, but the effects are rather week. Cells without data are blanked out.'}
x = ALEPlot(cervical, pred.cervical, J = which(names(cervical) %in% c("Num.of.pregnancies", "Age")), pred.fun = y.fun, NA.plot = FALSE)
```

The ALE plot shows similar interactions between Age and number of pregnancies as we have seen with [partial dependence plots](#pdp).
The age and number of pregnancies are naturally correlated, with a correlation of `r sprintf("%.2f", cor(cervical$Age, cervical$Num.of.pregnancies))`.
This means I would trust the ALE more than the marginal effect.


### Advantages

- ALE plots also work when features are correlated.
Partial dependence plots fail in this scenario because they marginalize over unlikely or even physically impossible combinations of feature values.
- ALE plots are faster to compute than PDPs and they scale with O(n), since the maximum number of intervals is the number of instances, amounting to one interval per data instance.
The PDP needs n times number of grid points estimations. 
For, let's say, 20 grid points, this would be 20x more predictions the model has to make.
- The interpretation of ALE plots is also clear: Conditional on a given x value, the effect of the feature on the prediction can be read from the ALE plot.
- 2D plot only shows interaction: The good thing is, when two features don't interact, the plot doesn't show anything.
This choice has also some negative consequences.
After all it's just a technical decision that's not inherent to the idea of ALE plots. 
It's technically possible to add the first order effects and show both.

### Disadvantages

- ALE plots can become a bit wobbly (many small ups and downs) with a high number of intervals
- No perfect solution for setting the number of intervals. 
If the number is too small, than the ALE plots will not be very accurate. 
If the number is too high, it can become wobbly.
- ALE plots are centered at zero.
This makes their interpretation nice, because the value at each point of the ALE curve is the difference to the mean prediction.
- Unlike PDPs, ALE plots don't have anything equivalent like ICE curves.
For PDPs, ICE curves are greate because they can reveal effect heterogeneity in the data, meaning that the effect of a feature looks different for subsets of the data.
For ALE plot you could only check per interval if the effect differs between the instances, but each interval has different instances so it is not equivalent to ICE curves.
- Each estimation of a local effect in an interval uses a different number of data instances.
This means that not all estimates are equally accurate (but still the best possible estimate).
- The choice to use the second-order effect for the 2D ALE computation is a bit annoying to interpret, since you always have to hold in your mind the first-order effects.
It's tempting to read the heat maps as the total effect of the two features, but it is only the additional effect of the interaction.
The pure second-order effect is interesting for discovering and exploring interactions, but for the interpretation of how the effect looks like, I think it more useful when the first-order effect is integrated into the heatmap.





[^ALE]: Apley, D. W. (n.d.). Visualizing the Effects of Predictor Variables in Black Box Supervised Learning Models, 1â€“36. Retrieved from https://arxiv.org/ftp/arxiv/papers/1612/1612.08468.pdf